<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Glass Ray Tracer</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #0a0a0f;
    color: #e0e0e8;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  #sidebar {
    width: 320px;
    min-width: 320px;
    background: #12121a;
    border-right: 1px solid #2a2a3a;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }
  #sidebar h1 {
    font-size: 1.3rem;
    padding: 20px;
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border-bottom: 1px solid #2a2a3a;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  #sidebar h1 span { font-size: 1.5rem; }
  .section {
    padding: 16px 20px;
    border-bottom: 1px solid #1e1e2e;
  }
  .section-title {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: #6a6a8a;
    margin-bottom: 12px;
  }
  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }
  .btn-primary {
    background: linear-gradient(135deg, #4a6cf7, #6366f1);
    color: white;
    width: 100%;
    padding: 12px;
    font-size: 1rem;
    font-weight: 600;
  }
  .btn-primary:hover { background: linear-gradient(135deg, #5b7bf8, #7577f2); }
  .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
  .btn-secondary {
    background: #1e1e2e;
    color: #c0c0d0;
    border: 1px solid #2a2a3a;
  }
  .btn-secondary:hover { background: #2a2a3a; }
  .btn-danger {
    background: #3a1a1a;
    color: #f87171;
    border: 1px solid #5a2a2a;
  }
  .btn-danger:hover { background: #4a2020; }
  .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
  .object-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
    max-height: 300px;
    overflow-y: auto;
  }
  .object-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    background: #1a1a28;
    border-radius: 8px;
    border: 1px solid #2a2a3a;
    cursor: pointer;
    transition: all 0.15s;
  }
  .object-item:hover { border-color: #4a6cf7; }
  .object-item.selected { border-color: #4a6cf7; background: #1a1a38; }
  .object-item .name { font-size: 0.85rem; }
  .object-item .type { font-size: 0.7rem; color: #6a6a8a; }
  .object-item .remove-btn {
    background: none;
    border: none;
    color: #6a6a8a;
    cursor: pointer;
    font-size: 1.1rem;
    padding: 2px 6px;
    border-radius: 4px;
  }
  .object-item .remove-btn:hover { color: #f87171; background: #3a1a1a; }
  .prop-group { margin-bottom: 12px; }
  .prop-label {
    font-size: 0.75rem;
    color: #8a8aa0;
    margin-bottom: 4px;
  }
  .prop-row {
    display: flex;
    gap: 6px;
  }
  .prop-row input {
    flex: 1;
    min-width: 0;
  }
  input[type="number"], input[type="range"], select {
    background: #1a1a28;
    border: 1px solid #2a2a3a;
    color: #e0e0e8;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 0.85rem;
    font-family: inherit;
    width: 100%;
  }
  input[type="number"]:focus, select:focus {
    outline: none;
    border-color: #4a6cf7;
  }
  select { cursor: pointer; }
  input[type="range"] {
    -webkit-appearance: none;
    height: 6px;
    border-radius: 3px;
    background: #2a2a3a;
    border: none;
    padding: 0;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #4a6cf7;
    cursor: pointer;
  }
  #render-section { padding: 20px; margin-top: auto; }
  #status {
    font-size: 0.8rem;
    color: #6a6a8a;
    text-align: center;
    margin-top: 10px;
  }
  #main {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #08080e;
    position: relative;
  }
  #canvas {
    image-rendering: pixelated;
    max-width: 100%;
    max-height: 100%;
  }
  .empty-state {
    text-align: center;
    color: #4a4a6a;
    padding: 20px;
    font-size: 0.85rem;
  }
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: #2a2a3a; border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: #3a3a4a; }
  .color-input-wrap {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  input[type="color"] {
    width: 32px;
    height: 32px;
    border: 1px solid #2a2a3a;
    border-radius: 6px;
    background: none;
    cursor: pointer;
    padding: 2px;
  }
</style>
</head>
<body>

<div id="sidebar">
  <h1><span>üíé</span> Glass Ray Tracer</h1>

  <div class="section">
    <div class="section-title">Add Object</div>
    <div class="btn-group">
      <button class="btn btn-secondary" onclick="addObject('sphere')">üîÆ Sphere</button>
      <button class="btn btn-secondary" onclick="addObject('cube')">üßä Cube</button>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Scene Objects</div>
    <div id="object-list" class="object-list">
      <div class="empty-state">No objects yet. Add some glass objects!</div>
    </div>
  </div>

  <div class="section" id="props-panel" style="display:none">
    <div class="section-title">Properties</div>
    <div class="prop-group">
      <div class="prop-label">Type</div>
      <select id="prop-type" onchange="updateProp('type', this.value)">
        <option value="sphere">Sphere</option>
        <option value="cube">Cube</option>
      </select>
    </div>
    <div class="prop-group">
      <div class="prop-label">Position (X, Y, Z)</div>
      <div class="prop-row">
        <input type="number" id="prop-px" step="0.1" onchange="updateProp('px', +this.value)">
        <input type="number" id="prop-py" step="0.1" onchange="updateProp('py', +this.value)">
        <input type="number" id="prop-pz" step="0.1" onchange="updateProp('pz', +this.value)">
      </div>
    </div>
    <div class="prop-group">
      <div class="prop-label">Size</div>
      <input type="number" id="prop-size" step="0.1" min="0.1" max="5" onchange="updateProp('size', +this.value)">
    </div>
    <div class="prop-group">
      <div class="prop-label">Index of Refraction</div>
      <input type="range" id="prop-ior" min="1.0" max="2.5" step="0.01" oninput="document.getElementById('ior-val').textContent=this.value; updateProp('ior', +this.value)">
      <div style="display:flex;justify-content:space-between;font-size:0.7rem;color:#6a6a8a;margin-top:2px">
        <span>1.0 (Air)</span><span id="ior-val">1.5</span><span>2.5 (Diamond)</span>
      </div>
    </div>
    <div class="prop-group">
      <div class="prop-label">Glass Tint</div>
      <div class="color-input-wrap">
        <input type="color" id="prop-color" value="#ffffff" onchange="updateProp('color', this.value)">
        <span style="font-size:0.8rem" id="color-label">#ffffff</span>
      </div>
    </div>
    <div class="prop-group">
      <div class="prop-label">Roughness</div>
      <input type="range" id="prop-roughness" min="0" max="0.5" step="0.01" oninput="document.getElementById('rough-val').textContent=this.value; updateProp('roughness', +this.value)">
      <div style="display:flex;justify-content:space-between;font-size:0.7rem;color:#6a6a8a;margin-top:2px">
        <span>Smooth</span><span id="rough-val">0</span><span>Frosted</span>
      </div>
    </div>
    <div style="margin-top:8px">
      <button class="btn btn-danger" style="width:100%" onclick="removeSelected()">Remove Object</button>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Render Settings</div>
    <div class="prop-group">
      <div class="prop-label">Resolution</div>
      <select id="resolution">
        <option value="400">400 √ó 300 (Fast)</option>
        <option value="640" selected>640 √ó 480 (Medium)</option>
        <option value="800">800 √ó 600 (High)</option>
        <option value="1024">1024 √ó 768 (Ultra)</option>
      </select>
    </div>
    <div class="prop-group">
      <div class="prop-label">Max Samples</div>
      <select id="max-samples">
        <option value="64">64 (Preview)</option>
        <option value="256" selected>256 (Good)</option>
        <option value="1024">1024 (High Quality)</option>
        <option value="4096">4096 (Ultra)</option>
      </select>
    </div>
  </div>

  <div id="render-section">
    <button class="btn btn-primary" id="render-btn" onclick="startRender()">üöÄ Render</button>
    <button class="btn btn-danger" id="stop-btn" style="width:100%;display:none;margin-top:8px" onclick="stopRender()">‚èπ Stop</button>
    <div id="status">Add objects and hit Render</div>
  </div>
</div>

<div id="main">
  <canvas id="canvas" width="640" height="480"></canvas>
</div>

<script>
// ============================================================
// Glass Ray Tracer - Full Path Tracer with Glass Materials
// ============================================================

// --- Scene State ---
let sceneObjects = [];
let selectedId = null;
let nextId = 1;
let rendering = false;
let sampleCount = 0;
let maxSamples = 256;
let accumBuffer = null;
let animFrame = null;

// --- Default scene with a few glass objects ---
function initDefaultScene() {
  addObject('sphere', { px: 0, py: 0.8, pz: -2, size: 0.8, ior: 1.52, color: '#e8f0ff', roughness: 0 });
  addObject('cube', { px: -1.8, py: 0.6, pz: -1.5, size: 0.6, ior: 1.45, color: '#ffe8f0', roughness: 0.02 });
  addObject('sphere', { px: 1.5, py: 0.5, pz: -1.2, size: 0.5, ior: 2.0, color: '#f0ffe8', roughness: 0 });
}

function addObject(type, props) {
  const obj = {
    id: nextId++,
    type,
    px: 0, py: 0.8, pz: -2,
    size: 0.8,
    ior: 1.5,
    color: '#ffffff',
    roughness: 0,
    ...props
  };
  sceneObjects.push(obj);
  refreshObjectList();
  selectObject(obj.id);
  return obj;
}

function removeObject(id) {
  sceneObjects = sceneObjects.filter(o => o.id !== id);
  if (selectedId === id) { selectedId = null; hideProps(); }
  refreshObjectList();
}

function removeSelected() {
  if (selectedId) removeObject(selectedId);
}

function selectObject(id) {
  selectedId = id;
  refreshObjectList();
  showProps();
}

function refreshObjectList() {
  const el = document.getElementById('object-list');
  if (sceneObjects.length === 0) {
    el.innerHTML = '<div class="empty-state">No objects yet. Add some glass objects!</div>';
    return;
  }
  el.innerHTML = sceneObjects.map(o => `
    <div class="object-item ${o.id === selectedId ? 'selected' : ''}" onclick="selectObject(${o.id})">
      <div>
        <div class="name">${o.type === 'sphere' ? 'üîÆ' : 'üßä'} ${o.type.charAt(0).toUpperCase() + o.type.slice(1)} #${o.id}</div>
        <div class="type">IOR: ${o.ior} | Pos: (${o.px.toFixed(1)}, ${o.py.toFixed(1)}, ${o.pz.toFixed(1)})</div>
      </div>
      <button class="remove-btn" onclick="event.stopPropagation();removeObject(${o.id})">‚úï</button>
    </div>
  `).join('');
}

function showProps() {
  const obj = sceneObjects.find(o => o.id === selectedId);
  if (!obj) return;
  document.getElementById('props-panel').style.display = '';
  document.getElementById('prop-type').value = obj.type;
  document.getElementById('prop-px').value = obj.px;
  document.getElementById('prop-py').value = obj.py;
  document.getElementById('prop-pz').value = obj.pz;
  document.getElementById('prop-size').value = obj.size;
  document.getElementById('prop-ior').value = obj.ior;
  document.getElementById('ior-val').textContent = obj.ior;
  document.getElementById('prop-color').value = obj.color;
  document.getElementById('color-label').textContent = obj.color;
  document.getElementById('prop-roughness').value = obj.roughness;
  document.getElementById('rough-val').textContent = obj.roughness;
}

function hideProps() {
  document.getElementById('props-panel').style.display = 'none';
}

function updateProp(key, val) {
  const obj = sceneObjects.find(o => o.id === selectedId);
  if (!obj) return;
  obj[key] = val;
  if (key === 'color') document.getElementById('color-label').textContent = val;
  refreshObjectList();
}

// --- Vector Math ---
function vec3(x, y, z) { return [x, y, z]; }
function vadd(a, b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
function vsub(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function vmul(a, s) { return [a[0]*s, a[1]*s, a[2]*s]; }
function vmulv(a, b) { return [a[0]*b[0], a[1]*b[1], a[2]*b[2]]; }
function vdot(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function vlen(a) { return Math.sqrt(vdot(a, a)); }
function vnorm(a) { const l = vlen(a); return l > 0 ? vmul(a, 1/l) : [0,0,0]; }
function vcross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function vreflect(v, n) { return vsub(v, vmul(n, 2*vdot(v, n))); }
function vlerp(a, b, t) { return vadd(vmul(a, 1-t), vmul(b, t)); }
function vmax(a, b) { return [Math.max(a[0],b[0]), Math.max(a[1],b[1]), Math.max(a[2],b[2])]; }
function vmin(a, b) { return [Math.min(a[0],b[0]), Math.min(a[1],b[1]), Math.min(a[2],b[2])]; }
function vabs(a) { return [Math.abs(a[0]), Math.abs(a[1]), Math.abs(a[2])]; }

// --- Random ---
let rngState = 12345;
function rngNext() {
  rngState = (rngState * 1103515245 + 12345) & 0x7fffffff;
  return rngState / 0x7fffffff;
}
function randomInUnitSphere() {
  while (true) {
    const v = [rngNext()*2-1, rngNext()*2-1, rngNext()*2-1];
    if (vdot(v, v) < 1) return v;
  }
}
function randomOnHemisphere(n) {
  const v = vnorm(randomInUnitSphere());
  return vdot(v, n) > 0 ? v : vmul(v, -1);
}
function randomInUnitDisk() {
  while (true) {
    const v = [rngNext()*2-1, rngNext()*2-1, 0];
    if (vdot(v, v) < 1) return v;
  }
}

// --- Color Helpers ---
function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3), 16) / 255;
  const g = parseInt(hex.slice(3,5), 16) / 255;
  const b = parseInt(hex.slice(5,7), 16) / 255;
  return [r, g, b];
}

// --- Ray-Object Intersection ---
function intersectSphere(ro, rd, center, radius) {
  const oc = vsub(ro, center);
  const a = vdot(rd, rd);
  const b = vdot(oc, rd);
  const c = vdot(oc, oc) - radius * radius;
  const disc = b * b - a * c;
  if (disc < 0) return null;
  const sqrtDisc = Math.sqrt(disc);
  let t = (-b - sqrtDisc) / a;
  if (t < 0.001) {
    t = (-b + sqrtDisc) / a;
    if (t < 0.001) return null;
  }
  const p = vadd(ro, vmul(rd, t));
  const n = vnorm(vsub(p, center));
  return { t, p, n };
}

function intersectBox(ro, rd, center, halfSize) {
  const mn = vsub(center, [halfSize, halfSize, halfSize]);
  const mx = vadd(center, [halfSize, halfSize, halfSize]);
  let tmin = -Infinity, tmax = Infinity;
  let nmin = [0,0,0];
  for (let i = 0; i < 3; i++) {
    if (Math.abs(rd[i]) < 1e-8) {
      if (ro[i] < mn[i] || ro[i] > mx[i]) return null;
    } else {
      let t1 = (mn[i] - ro[i]) / rd[i];
      let t2 = (mx[i] - ro[i]) / rd[i];
      let n1 = [0,0,0]; n1[i] = -1;
      let n2 = [0,0,0]; n2[i] = 1;
      if (t1 > t2) { [t1, t2] = [t2, t1]; [n1, n2] = [n2, n1]; }
      if (t1 > tmin) { tmin = t1; nmin = n1; }
      if (t2 < tmax) { tmax = t2; }
      if (tmin > tmax) return null;
    }
  }
  let t = tmin;
  let n = nmin;
  if (t < 0.001) {
    // We're inside the box, use exit point
    t = tmax;
    // Flip normal for inside hit
    n = [0,0,0];
    for (let i = 0; i < 3; i++) {
      const p = ro[i] + rd[i] * t;
      if (Math.abs(p - (center[i] + halfSize)) < 0.001) n[i] = 1;
      else if (Math.abs(p - (center[i] - halfSize)) < 0.001) n[i] = -1;
    }
    if (vlen(n) < 0.5) n = vmul(rd, -1); // fallback
    n = vnorm(n);
    if (t < 0.001) return null;
  }
  const p = vadd(ro, vmul(rd, t));
  return { t, p, n };
}

function intersectPlane(ro, rd, y) {
  if (Math.abs(rd[1]) < 1e-8) return null;
  const t = (y - ro[1]) / rd[1];
  if (t < 0.001) return null;
  const p = vadd(ro, vmul(rd, t));
  return { t, p, n: [0, 1, 0] };
}

// --- Scene Intersection ---
function intersectScene(ro, rd, objects) {
  let closest = null;
  let closestT = Infinity;
  let hitObj = null;

  // Ground plane
  const gnd = intersectPlane(ro, rd, 0);
  if (gnd && gnd.t < closestT) {
    closestT = gnd.t;
    closest = gnd;
    hitObj = { type: 'ground' };
  }

  for (const obj of objects) {
    let hit;
    if (obj.type === 'sphere') {
      hit = intersectSphere(ro, rd, [obj.px, obj.py, obj.pz], obj.size);
    } else {
      hit = intersectBox(ro, rd, [obj.px, obj.py, obj.pz], obj.size);
    }
    if (hit && hit.t < closestT) {
      closestT = hit.t;
      closest = hit;
      hitObj = obj;
    }
  }

  return closest ? { ...closest, obj: hitObj } : null;
}

// --- Fresnel (Schlick approximation) ---
function fresnelSchlick(cosTheta, ior1, ior2) {
  let r0 = (ior1 - ior2) / (ior1 + ior2);
  r0 = r0 * r0;
  return r0 + (1 - r0) * Math.pow(1 - cosTheta, 5);
}

// --- Refract ---
function refract(uv, n, etaiOverEtat) {
  const cosTheta = Math.min(-vdot(uv, n), 1.0);
  const rOutPerp = vmul(vadd(uv, vmul(n, cosTheta)), etaiOverEtat);
  const perpLenSq = vdot(rOutPerp, rOutPerp);
  if (perpLenSq > 1.0) return null; // Total internal reflection
  const rOutParallel = vmul(n, -Math.sqrt(Math.abs(1.0 - perpLenSq)));
  return vnorm(vadd(rOutPerp, rOutParallel));
}

// --- Sky / Environment ---
function skyColor(rd) {
  const t = 0.5 * (rd[1] + 1.0);
  const sky = vlerp([0.8, 0.85, 0.95], [0.3, 0.5, 0.9], t);
  // Sun
  const sunDir = vnorm([0.8, 0.6, -0.3]);
  const sunDot = Math.max(0, vdot(rd, sunDir));
  const sun = vmul([1, 0.95, 0.85], Math.pow(sunDot, 256) * 8 + Math.pow(sunDot, 32) * 0.5);
  return vadd(sky, sun);
}

// --- Checkerboard ground ---
function groundColor(p) {
  const scale = 1.0;
  const cx = Math.floor(p[0] * scale + 1000);
  const cz = Math.floor(p[2] * scale + 1000);
  const checker = (cx + cz) % 2 === 0;
  return checker ? [0.85, 0.85, 0.85] : [0.35, 0.35, 0.4];
}

// --- Path Trace ---
function trace(ro, rd, objects, depth) {
  if (depth <= 0) return [0, 0, 0];

  const hit = intersectScene(ro, rd, objects);
  if (!hit) return skyColor(rd);

  const { p, n, obj } = hit;

  // Ground plane - diffuse with checkerboard
  if (obj.type === 'ground') {
    const albedo = groundColor(p);
    // Direct lighting from sun
    const sunDir = vnorm([0.8, 0.6, -0.3]);
    const shadowHit = intersectScene(vadd(p, vmul(n, 0.001)), sunDir, objects);
    let light;
    if (shadowHit && shadowHit.obj.type !== 'ground') {
      // In shadow but glass objects let some light through
      light = 0.3;
    } else {
      light = 0.3 + 0.7 * Math.max(0, vdot(n, sunDir));
    }
    // Indirect bounce
    const bounceDir = randomOnHemisphere(n);
    const indirect = trace(vadd(p, vmul(n, 0.001)), bounceDir, objects, depth - 1);
    return vadd(vmul(albedo, light), vmulv(albedo, vmul(indirect, 0.15)));
  }

  // Glass material
  const tint = hexToRgb(obj.color);
  const roughness = obj.roughness || 0;

  // Determine if we're entering or exiting
  let frontFace = vdot(rd, n) < 0;
  let normal = frontFace ? n : vmul(n, -1);
  let ior1 = frontFace ? 1.0 : obj.ior;
  let ior2 = frontFace ? obj.ior : 1.0;

  // Add roughness perturbation to normal
  let perturbedNormal = normal;
  if (roughness > 0) {
    const perturb = vmul(randomInUnitSphere(), roughness);
    perturbedNormal = vnorm(vadd(normal, perturb));
    if (vdot(perturbedNormal, normal) < 0.1) perturbedNormal = normal;
  }

  const cosTheta = Math.min(Math.abs(vdot(rd, perturbedNormal)), 1.0);
  const reflectance = fresnelSchlick(cosTheta, ior1, ior2);

  const offset = vmul(perturbedNormal, 0.001);

  if (rngNext() < reflectance) {
    // Reflect
    const reflected = vreflect(rd, perturbedNormal);
    const result = trace(vadd(p, offset), vnorm(reflected), objects, depth - 1);
    return vmulv(result, tint);
  } else {
    // Refract
    const ratio = ior1 / ior2;
    const refracted = refract(vnorm(rd), perturbedNormal, ratio);
    if (!refracted) {
      // Total internal reflection
      const reflected = vreflect(rd, perturbedNormal);
      const result = trace(vadd(p, offset), vnorm(reflected), objects, depth - 1);
      return vmulv(result, tint);
    }
    // Beer's law absorption for colored glass (when exiting)
    let absorption = [1, 1, 1];
    if (!frontFace) {
      const dist = hit.t;
      absorption = [
        Math.exp(-(1 - tint[0]) * dist * 2),
        Math.exp(-(1 - tint[1]) * dist * 2),
        Math.exp(-(1 - tint[2]) * dist * 2)
      ];
    }
    const result = trace(vsub(p, offset), vnorm(refracted), objects, depth - 1);
    return vmulv(result, absorption);
  }
}

// --- Render ---
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function startRender() {
  if (rendering) return;

  const resVal = parseInt(document.getElementById('resolution').value);
  const aspect = 4 / 3;
  const W = resVal;
  const H = Math.round(resVal / aspect);
  canvas.width = W;
  canvas.height = H;

  maxSamples = parseInt(document.getElementById('max-samples').value);
  accumBuffer = new Float64Array(W * H * 3);
  sampleCount = 0;
  rendering = true;

  document.getElementById('render-btn').disabled = true;
  document.getElementById('stop-btn').style.display = '';

  renderLoop();
}

function stopRender() {
  rendering = false;
  if (animFrame) cancelAnimationFrame(animFrame);
  document.getElementById('render-btn').disabled = false;
  document.getElementById('stop-btn').style.display = 'none';
  document.getElementById('status').textContent = `Stopped at ${sampleCount} samples`;
}

function renderLoop() {
  if (!rendering) return;

  const W = canvas.width;
  const H = canvas.height;
  const objects = sceneObjects;

  // Camera
  const camPos = [0, 2.5, 3];
  const camTarget = [0, 0.5, -1];
  const camFwd = vnorm(vsub(camTarget, camPos));
  const camRight = vnorm(vcross(camFwd, [0, 1, 0]));
  const camUp = vcross(camRight, camFwd);
  const fov = 0.8; // ~45 degrees half-angle tangent
  const aperture = 0.02;
  const focusDist = vlen(vsub(camTarget, camPos));

  // Render a batch of pixels per frame for responsiveness
  const samplesPerFrame = 1;

  rngState = sampleCount * 73856093 + 19349663;

  for (let s = 0; s < samplesPerFrame; s++) {
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        rngState = (x * 73856093 ^ y * 19349663 ^ sampleCount * 83492791) & 0x7fffffff;
        if (rngState === 0) rngState = 1;

        const u = (2 * (x + rngNext()) / W - 1) * fov * (W / H);
        const v = (1 - 2 * (y + rngNext()) / H) * fov;

        // DOF
        const disk = vmul(randomInUnitDisk(), aperture);
        const offset = vadd(vmul(camRight, disk[0]), vmul(camUp, disk[1]));

        const dir = vnorm(vadd(vadd(vmul(camRight, u * focusDist), vmul(camUp, v * focusDist)), vmul(camFwd, focusDist)));
        const ro = vadd(camPos, offset);
        const rd = vnorm(vsub(vadd(camPos, vmul(dir, focusDist)), ro));

        const color = trace(ro, rd, objects, 6);

        const idx = (y * W + x) * 3;
        accumBuffer[idx] += color[0];
        accumBuffer[idx + 1] += color[1];
        accumBuffer[idx + 2] += color[2];
      }
    }
    sampleCount++;
  }

  // Write to canvas
  const imgData = ctx.createImageData(W, H);
  const invS = 1 / sampleCount;
  for (let i = 0; i < W * H; i++) {
    const r = Math.sqrt(accumBuffer[i * 3] * invS);
    const g = Math.sqrt(accumBuffer[i * 3 + 1] * invS);
    const b = Math.sqrt(accumBuffer[i * 3 + 2] * invS);
    imgData.data[i * 4] = Math.min(255, r * 255) | 0;
    imgData.data[i * 4 + 1] = Math.min(255, g * 255) | 0;
    imgData.data[i * 4 + 2] = Math.min(255, b * 255) | 0;
    imgData.data[i * 4 + 3] = 255;
  }
  ctx.putImageData(imgData, 0, 0);

  document.getElementById('status').textContent = `Sample ${sampleCount} / ${maxSamples}`;

  if (sampleCount >= maxSamples) {
    rendering = false;
    document.getElementById('render-btn').disabled = false;
    document.getElementById('stop-btn').style.display = 'none';
    document.getElementById('status').textContent = `Done! ${sampleCount} samples rendered`;
    return;
  }

  animFrame = requestAnimationFrame(renderLoop);
}

// --- Init ---
initDefaultScene();

// Draw initial placeholder
ctx.fillStyle = '#12121a';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = '#4a4a6a';
ctx.font = '16px system-ui';
ctx.textAlign = 'center';
ctx.fillText('Press Render to start ray tracing', canvas.width/2, canvas.height/2);
</script>
</body>
</html>
