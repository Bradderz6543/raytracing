<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Glass Path Tracer</title>
<style>
  :root {
    --bg-darkest: #0d0d14;
    --bg-dark: #14141e;
    --bg-panel: #1a1a28;
    --bg-input: #222234;
    --bg-hover: #2a2a3e;
    --border: #333348;
    --border-light: #444460;
    --accent: #4e9af5;
    --accent-hover: #3a86e0;
    --accent-dim: #1e3a6a;
    --accent-glow: rgba(78, 154, 245, 0.15);
    --danger: #e94560;
    --danger-hover: #c73650;
    --success: #4ecca3;
    --success-hover: #3db890;
    --warning: #f0a030;
    --text: #d8d8e8;
    --text-dim: #8888a8;
    --text-muted: #555570;
    --header-bg: #161624;
    --selected: rgba(78, 154, 245, 0.12);
    --selected-border: rgba(78, 154, 245, 0.5);
    --radius: 6px;
    --radius-sm: 4px;
    --transition: 0.15s ease;
    --shadow: 0 2px 8px rgba(0,0,0,0.3);
    --shadow-lg: 0 4px 16px rgba(0,0,0,0.4);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', system-ui, sans-serif;
    background: var(--bg-darkest);
    color: var(--text);
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    font-size: 13px;
    -webkit-font-smoothing: antialiased;
  }

  /* ===== TOP TOOLBAR ===== */
  #toolbar {
    height: 44px;
    min-height: 44px;
    background: var(--header-bg);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 14px;
    gap: 8px;
    z-index: 100;
    box-shadow: 0 1px 4px rgba(0,0,0,0.2);
  }

  .toolbar-brand {
    font-weight: 700;
    font-size: 14px;
    color: var(--accent);
    margin-right: 16px;
    display: flex;
    align-items: center;
    gap: 7px;
    user-select: none;
    letter-spacing: -0.3px;
  }

  .toolbar-brand svg { width: 20px; height: 20px; filter: drop-shadow(0 0 4px rgba(78,154,245,0.4)); }

  .toolbar-divider {
    width: 1px;
    height: 24px;
    background: var(--border);
    margin: 0 6px;
  }

  .toolbar-group {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .toolbar-btn {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 6px 12px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    color: var(--text);
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition);
    white-space: nowrap;
    user-select: none;
  }

  .toolbar-btn:hover {
    background: var(--bg-hover);
    border-color: var(--border-light);
    transform: translateY(-1px);
    box-shadow: var(--shadow);
  }

  .toolbar-btn:active { transform: translateY(0); }

  .toolbar-btn svg { width: 14px; height: 14px; opacity: 0.8; }

  .toolbar-btn.primary {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }

  .toolbar-btn.primary:hover {
    background: var(--accent-hover);
    border-color: var(--accent-hover);
  }

  .toolbar-btn.render-btn {
    background: linear-gradient(135deg, var(--success), #3db890);
    border-color: var(--success);
    color: #0a0a0a;
    font-weight: 700;
    padding: 6px 20px;
    letter-spacing: 0.3px;
    box-shadow: 0 0 12px rgba(78, 204, 163, 0.2);
  }

  .toolbar-btn.render-btn:hover {
    background: linear-gradient(135deg, var(--success-hover), #35a880);
    border-color: var(--success-hover);
    box-shadow: 0 0 20px rgba(78, 204, 163, 0.35);
  }

  .toolbar-btn.stop-btn {
    background: linear-gradient(135deg, var(--danger), #c73650);
    border-color: var(--danger);
    color: #fff;
    font-weight: 700;
    padding: 6px 20px;
  }

  .toolbar-btn.stop-btn:hover {
    background: linear-gradient(135deg, var(--danger-hover), #b02e45);
    border-color: var(--danger-hover);
  }

  .toolbar-btn.back-btn {
    background: var(--bg-input);
    border-color: var(--border);
    color: var(--text);
  }

  .toolbar-spacer { flex: 1; }

  .toolbar-info {
    font-size: 11px;
    color: var(--text-dim);
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .toolbar-info .cam-info {
    font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
    font-size: 10px;
    color: var(--text-muted);
    background: var(--bg-input);
    padding: 3px 8px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border);
  }

  .mode-badge {
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    padding: 3px 10px;
    border-radius: var(--radius-sm);
    background: var(--accent-dim);
    color: var(--accent);
    border: 1px solid rgba(78, 154, 245, 0.3);
  }

  .mode-badge.rendering {
    background: rgba(78, 204, 163, 0.15);
    color: var(--success);
    border-color: rgba(78, 204, 163, 0.3);
    animation: badgePulse 2s infinite;
  }

  @keyframes badgePulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(78, 204, 163, 0); }
    50% { box-shadow: 0 0 8px 2px rgba(78, 204, 163, 0.2); }
  }

  /* ===== MAIN LAYOUT ===== */
  #main {
    flex: 1;
    display: flex;
    overflow: hidden;
  }

  /* ===== LEFT SIDEBAR ===== */
  #sidebar {
    width: 290px;
    min-width: 290px;
    background: var(--bg-panel);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
  }

  .panel {
    border-bottom: 1px solid var(--border);
  }

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 14px;
    background: var(--bg-dark);
    cursor: pointer;
    user-select: none;
    transition: background var(--transition);
  }

  .panel-header:hover { background: var(--bg-hover); }

  .panel-header h3 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    color: var(--text-dim);
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .panel-header h3 svg { width: 13px; height: 13px; opacity: 0.6; }

  .panel-header .arrow {
    font-size: 10px;
    color: var(--text-muted);
    transition: transform var(--transition);
  }

  .panel-header.collapsed .arrow { transform: rotate(-90deg); }

  .panel-body {
    padding: 10px 14px;
    overflow: hidden;
    transition: max-height 0.25s ease, padding 0.25s ease;
  }

  .panel-body.collapsed {
    max-height: 0 !important;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
  }

  /* ===== OBJECT LIST ===== */
  #object-list {
    list-style: none;
    max-height: 260px;
    overflow-y: auto;
  }

  #object-list::-webkit-scrollbar { width: 4px; }
  #object-list::-webkit-scrollbar-track { background: transparent; }
  #object-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .obj-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 7px 10px;
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: all var(--transition);
    margin-bottom: 2px;
    border: 1px solid transparent;
  }

  .obj-item:hover { background: var(--bg-hover); }

  .obj-item.selected {
    background: var(--selected);
    border-color: var(--selected-border);
    box-shadow: inset 0 0 0 1px rgba(78, 154, 245, 0.1);
  }

  .obj-item .obj-icon {
    width: 26px;
    height: 26px;
    border-radius: var(--radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    flex-shrink: 0;
  }

  .obj-item .obj-name {
    flex: 1;
    font-size: 12px;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .obj-item .obj-type {
    font-size: 10px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .obj-item .obj-delete {
    opacity: 0;
    background: none;
    border: none;
    color: var(--danger);
    cursor: pointer;
    font-size: 14px;
    padding: 2px 4px;
    border-radius: 3px;
    transition: all var(--transition);
  }

  .obj-item:hover .obj-delete { opacity: 0.6; }
  .obj-item .obj-delete:hover { opacity: 1; background: rgba(233, 69, 96, 0.15); }

  .empty-msg {
    color: var(--text-muted);
    font-size: 11px;
    font-style: italic;
    padding: 16px 0;
    text-align: center;
  }

  /* ===== PROPERTIES PANEL ===== */
  .prop-group {
    margin-bottom: 12px;
  }

  .prop-group:last-child { margin-bottom: 0; }

  .prop-label {
    display: block;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-muted);
    margin-bottom: 5px;
  }

  .prop-row {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  .prop-row .axis-label {
    font-size: 10px;
    font-weight: 700;
    width: 14px;
    text-align: center;
    flex-shrink: 0;
  }

  .axis-x { color: #e06060; }
  .axis-y { color: #60c060; }
  .axis-z { color: #6080e0; }

  input[type="number"],
  input[type="text"],
  select {
    width: 100%;
    padding: 6px 8px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: var(--radius-sm);
    font-size: 12px;
    font-family: inherit;
    outline: none;
    transition: border-color var(--transition), box-shadow var(--transition);
  }

  input[type="number"]:focus,
  input[type="text"]:focus,
  select:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  input[type="number"] {
    -moz-appearance: textfield;
    font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
    font-size: 11px;
  }

  input[type="number"]::-webkit-inner-spin-button,
  input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
  }

  input[type="color"] {
    width: 100%;
    height: 30px;
    padding: 2px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    cursor: pointer;
    outline: none;
  }

  input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
  input[type="color"]::-webkit-color-swatch { border: none; border-radius: 2px; }

  select {
    cursor: pointer;
    -webkit-appearance: none;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%235a5a70'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    padding-right: 24px;
  }

  /* Custom range slider */
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    margin: 6px 0;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--bg-panel);
    box-shadow: 0 1px 4px rgba(0,0,0,0.4);
    transition: transform 0.1s ease;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.15);
  }

  /* ===== VIEWPORT ===== */
  #viewport {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-darkest);
    position: relative;
    overflow: hidden;
  }

  #viewport canvas {
    image-rendering: auto;
  }

  #viewport canvas.pixelated {
    image-rendering: pixelated;
  }

  /* Viewport overlay hints */
  .viewport-hint {
    position: absolute;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 10px;
    color: var(--text-muted);
    background: rgba(0,0,0,0.5);
    padding: 4px 12px;
    border-radius: var(--radius);
    pointer-events: none;
    opacity: 0.7;
    transition: opacity 0.3s;
    white-space: nowrap;
  }

  /* ===== STATUS BAR ===== */
  #statusbar {
    height: 26px;
    min-height: 26px;
    background: var(--header-bg);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 14px;
    font-size: 11px;
    color: var(--text-muted);
    gap: 16px;
  }

  .status-item {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: var(--success);
  }

  .status-dot.idle { background: var(--text-muted); }
  .status-dot.rendering { background: var(--success); animation: pulse 1s infinite; }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* ===== RENDER OVERLAY ===== */
  #render-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 10;
  }

  #render-overlay.active { display: flex; }

  .render-progress {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(10,10,20,0.85);
    backdrop-filter: blur(12px);
    padding: 10px 20px;
    border-radius: var(--radius);
    border: 1px solid var(--border);
    font-size: 12px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 14px;
    pointer-events: auto;
    box-shadow: var(--shadow-lg);
  }

  .progress-bar {
    width: 140px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--success), #6eecc3);
    border-radius: 2px;
    transition: width 0.3s ease;
  }

  /* ===== NO SELECTION STATE ===== */
  .no-selection {
    color: var(--text-muted);
    font-size: 11px;
    font-style: italic;
    text-align: center;
    padding: 16px 0;
  }

  /* ===== SCROLLBAR ===== */
  #sidebar::-webkit-scrollbar { width: 5px; }
  #sidebar::-webkit-scrollbar-track { background: transparent; }
  #sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* ===== HIDDEN ===== */
  .hidden { display: none !important; }

  /* ===== RENDER SETTINGS INLINE ===== */
  .settings-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }

  .settings-row:last-child { margin-bottom: 0; }

  .settings-row label {
    font-size: 11px;
    color: var(--text-dim);
    white-space: nowrap;
    min-width: 72px;
  }

  .settings-row input, .settings-row select {
    flex: 1;
  }

  /* ===== ADD BUTTONS IN SIDEBAR ===== */
  .add-buttons {
    display: flex;
    gap: 6px;
    margin-top: 8px;
  }

  .add-buttons .toolbar-btn {
    flex: 1;
    justify-content: center;
    font-size: 11px;
    padding: 5px 8px;
  }

  /* ===== PROP VALUE DISPLAY ===== */
  .prop-value-display {
    font-family: 'SF Mono', 'Consolas', monospace;
    font-size: 10px;
    color: var(--text-dim);
    min-width: 32px;
    text-align: right;
  }

  /* ===== ENVIRONMENT PANEL ===== */
  .env-preview {
    width: 100%;
    height: 40px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border);
    margin-bottom: 8px;
  }
</style>
</head>
<body>

<!-- ===== TOP TOOLBAR ===== -->
<div id="toolbar">
  <div class="toolbar-brand">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="10"/><path d="M8 12l2-6 4 10 2-4"/>
    </svg>
    Glass Path Tracer
  </div>

  <div class="toolbar-divider"></div>

  <div class="toolbar-group" id="edit-tools">
    <button class="toolbar-btn" onclick="addSphere()" title="Add Glass Sphere">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="8"/></svg>
      Sphere
    </button>
    <button class="toolbar-btn" onclick="addCube()" title="Add Glass Cube">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16" rx="1"/></svg>
      Cube
    </button>
    <button class="toolbar-btn" onclick="duplicateSelected()" title="Duplicate Selected" id="btn-duplicate">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="8" y="8" width="12" height="12" rx="1"/><path d="M4 16V5a1 1 0 011-1h11"/></svg>
      Dup
    </button>
  </div>

  <div class="toolbar-divider"></div>

  <div class="toolbar-group">
    <button class="toolbar-btn" onclick="toggleWireframe()" title="Toggle Wireframe" id="btn-wireframe">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
      Wire
    </button>
  </div>

  <div class="toolbar-divider"></div>

  <div class="toolbar-group">
    <button class="toolbar-btn render-btn" id="btn-render" onclick="startRender()">▶ Render</button>
    <button class="toolbar-btn stop-btn hidden" id="btn-stop" onclick="stopRender()">■ Stop</button>
    <button class="toolbar-btn back-btn hidden" id="btn-back" onclick="backToEdit()">← Edit</button>
  </div>

  <div class="toolbar-spacer"></div>

  <div class="toolbar-info">
    <span class="mode-badge" id="mode-badge">PREVIEW</span>
    <span class="cam-info" id="cam-info">cam: 0.0, 2.5, 3.0</span>
  </div>
</div>

<!-- ===== MAIN AREA ===== -->
<div id="main">

  <!-- LEFT SIDEBAR -->
  <div id="sidebar">

    <!-- SCENE OBJECTS -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 16V8a2 2 0 00-1-1.73l-7-4a2 2 0 00-2 0l-7 4A2 2 0 003 8v8a2 2 0 001 1.73l7 4a2 2 0 002 0l7-4A2 2 0 0021 16z"/></svg>
          Scene Objects
        </h3>
        <span class="arrow">▼</span>
      </div>
      <div class="panel-body">
        <ul id="object-list">
          <li class="empty-msg">No objects — add one above</li>
        </ul>
      </div>
    </div>

    <!-- PROPERTIES -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
          Properties
        </h3>
        <span class="arrow">▼</span>
      </div>
      <div class="panel-body" id="properties-panel">
        <div class="no-selection" id="no-selection-msg">Select an object to edit properties</div>
        <div id="prop-editor" class="hidden">
          <div class="prop-group">
            <span class="prop-label">Position</span>
            <div class="prop-row">
              <span class="axis-label axis-x">X</span>
              <input type="number" id="prop-px" step="0.1" onchange="updateSelectedProp()">
              <span class="axis-label axis-y">Y</span>
              <input type="number" id="prop-py" step="0.1" onchange="updateSelectedProp()">
              <span class="axis-label axis-z">Z</span>
              <input type="number" id="prop-pz" step="0.1" onchange="updateSelectedProp()">
            </div>
          </div>
          <div class="prop-group">
            <span class="prop-label">Size</span>
            <div class="prop-row">
              <input type="range" id="prop-size-slider" min="0.1" max="3" step="0.05" style="flex:1" oninput="document.getElementById('prop-size').value=this.value; document.getElementById('size-val').textContent=parseFloat(this.value).toFixed(2); updateSelectedProp()">
              <span class="prop-value-display" id="size-val">1.00</span>
            </div>
            <input type="number" id="prop-size" step="0.05" min="0.1" max="5" onchange="document.getElementById('prop-size-slider').value=this.value; document.getElementById('size-val').textContent=parseFloat(this.value).toFixed(2); updateSelectedProp()">
          </div>
          <div class="prop-group">
            <span class="prop-label">Color / Tint</span>
            <input type="color" id="prop-color" onchange="updateSelectedProp()">
          </div>
          <div class="prop-group">
            <span class="prop-label">IOR (Index of Refraction)</span>
            <div class="prop-row">
              <input type="range" id="prop-ior-slider" min="1.0" max="3.0" step="0.01" style="flex:1" oninput="document.getElementById('prop-ior').value=this.value; document.getElementById('ior-val').textContent=parseFloat(this.value).toFixed(2); updateSelectedProp()">
              <span class="prop-value-display" id="ior-val">1.50</span>
            </div>
            <input type="number" id="prop-ior" step="0.01" min="1.0" max="3.0" onchange="document.getElementById('prop-ior-slider').value=this.value; document.getElementById('ior-val').textContent=parseFloat(this.value).toFixed(2); updateSelectedProp()">
          </div>
        </div>
      </div>
    </div>

    <!-- RENDER SETTINGS -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.68 15a1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 009 4.68a1.65 1.65 0 001-1.51V3a2 2 0 014 0v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 9a1.65 1.65 0 001.51 1H21a2 2 0 010 4h-.09a1.65 1.65 0 00-1.51 1z"/></svg>
          Render Settings
        </h3>
        <span class="arrow">▼</span>
      </div>
      <div class="panel-body">
        <div class="settings-row">
          <label>Resolution</label>
          <select id="res-scale">
            <option value="0.25">Quarter (fast)</option>
            <option value="0.5" selected>Half</option>
            <option value="1">Full (slow)</option>
          </select>
        </div>
        <div class="settings-row">
          <label>Bounces</label>
          <input type="number" id="max-bounces" value="8" min="1" max="20">
        </div>
        <div class="settings-row">
          <label>Target SPP</label>
          <input type="number" id="target-spp" value="100" min="1" max="10000">
        </div>
      </div>
    </div>

    <!-- CAMERA -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/><circle cx="12" cy="13" r="4"/></svg>
          Camera
        </h3>
        <span class="arrow">▼</span>
      </div>
      <div class="panel-body">
        <div class="settings-row">
          <label>FOV</label>
          <input type="range" id="cam-fov" min="20" max="120" value="60" step="1" oninput="camera.fov=+this.value; document.getElementById('fov-val').textContent=this.value+'°'; drawPreview()">
          <span class="prop-value-display" id="fov-val">60°</span>
        </div>
        <div class="settings-row">
          <label>Focus Dist</label>
          <input type="range" id="cam-focus" min="0.5" max="30" value="5" step="0.1" oninput="camera.focusDist=+this.value; document.getElementById('focus-val').textContent=this.value; drawPreview()">
          <span class="prop-value-display" id="focus-val">5</span>
        </div>
        <div class="settings-row">
          <label>Aperture</label>
          <input type="range" id="cam-aperture" min="0" max="1.0" value="0.0" step="0.01" oninput="camera.aperture=+this.value; document.getElementById('aperture-val').textContent=parseFloat(this.value).toFixed(2); drawPreview()">
          <span class="prop-value-display" id="aperture-val">0.00</span>
        </div>
        <div class="settings-row">
          <label>Reset</label>
          <button class="toolbar-btn" onclick="resetCamera()" style="font-size:11px;padding:4px 12px;">Reset Camera</button>
        </div>
      </div>
    </div>

    <!-- ENVIRONMENT -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"/></svg>
          Environment
        </h3>
        <span class="arrow">▼</span>
      </div>
      <div class="panel-body">
        <canvas class="env-preview" id="env-preview"></canvas>
        <div class="settings-row">
          <label>Preset</label>
          <select id="env-preset" onchange="applyEnvironmentPreset(this.value)">
            <option value="default" selected>Default</option>
            <option value="cornell">Cornell Box</option>
            <option value="sky">Sky</option>
            <option value="studio">Studio</option>
            <option value="dark">Dark + Colored Lights</option>
          </select>
        </div>
        <div class="settings-row">
          <label>Sky Intensity</label>
          <input type="range" id="sky-intensity" min="0" max="5.0" step="0.1" value="1.5" oninput="skyIntensity=+this.value; drawPreview()">
        </div>
        <div class="settings-row">
          <label>Sun Power</label>
          <input type="range" id="sun-power" min="0" max="20" step="0.5" value="10" oninput="sunPower=+this.value; drawPreview()">
        </div>
      </div>
    </div>

  </div>

  <!-- VIEWPORT -->
  <div id="viewport">
    <canvas id="preview-canvas"></canvas>
    <canvas id="render-canvas" class="hidden pixelated"></canvas>
    <div id="render-overlay">
      <div class="render-progress">
        <div class="progress-bar"><div class="progress-bar-fill" id="progress-fill"></div></div>
        <span id="render-status-text">0 / 100 spp</span>
      </div>
    </div>
    <div class="viewport-hint" id="viewport-hint">LMB: Orbit · RMB/Shift+LMB: Pan · Scroll: Zoom</div>
  </div>

</div>

<!-- ===== STATUS BAR ===== -->
<div id="statusbar">
  <div class="status-item">
    <div class="status-dot idle" id="status-dot"></div>
    <span id="status-text">Ready</span>
  </div>
  <div class="status-item" id="status-objects">Objects: 0</div>
  <div class="status-item" id="status-resolution"></div>
  <div style="flex:1"></div>
  <div class="status-item" id="status-fps" style="font-family:monospace;font-size:10px;"></div>
</div>

<script>
// ============================================================
// Scene & State
// ============================================================
const sceneObjects = [];
let selectedIndex = -1;
let appMode = 'edit'; // 'edit' or 'render'
let rendering = false;
let sampleCount = 0;
let accumBuffer = null;
let animFrameId = null;
let wireframeMode = false;
let skyIntensity = 1.5;
let sunPower = 10;

// ============================================================
// Camera (orbit camera)
// ============================================================
const camera = {
  target: [0, 0.8, -3],
  distance: 8,
  theta: 0.3,   // horizontal angle
  phi: 0.45,    // vertical angle (from top)
  fov: 60,
  focusDist: 5,
  aperture: 0.0,
};

// Environment preset state
let currentEnvPreset = 'default';
let envRoomColor = null;       // null = no room (use sky)
let envRoomEmission = null;    // for emissive walls (Cornell Box)
let envLights = [];            // extra point/area lights for presets

function getCameraPos() {
  const sinP = Math.sin(camera.phi);
  const cosP = Math.cos(camera.phi);
  const sinT = Math.sin(camera.theta);
  const cosT = Math.cos(camera.theta);
  return [
    camera.target[0] + camera.distance * sinP * sinT,
    camera.target[1] + camera.distance * cosP,
    camera.target[2] + camera.distance * sinP * cosT
  ];
}

function resetCamera() {
  camera.target = [0, 0.8, -3];
  camera.distance = 8;
  camera.theta = 0.3;
  camera.phi = 0.45;
  camera.fov = 60;
  camera.focusDist = 5;
  camera.aperture = 0.0;
  document.getElementById('cam-fov').value = 60;
  document.getElementById('fov-val').textContent = '60°';
  document.getElementById('cam-focus').value = 5;
  document.getElementById('focus-val').textContent = '5';
  document.getElementById('cam-aperture').value = 0;
  document.getElementById('aperture-val').textContent = '0.00';
  updateCamInfo();
  drawPreview();
}

function updateCamInfo() {
  const p = getCameraPos();
  document.getElementById('cam-info').textContent =
    `cam: ${p[0].toFixed(1)}, ${p[1].toFixed(1)}, ${p[2].toFixed(1)}`;
}

// ============================================================
// Camera Controls
// ============================================================
let isDragging = false;
let dragButton = -1;
let lastMouse = [0, 0];

function initCameraControls() {
  const vp = document.getElementById('viewport');
  let mouseDownPos = [0, 0];
  let mouseDownTime = 0;

  vp.addEventListener('mousedown', (e) => {
    if (appMode !== 'edit') return;
    isDragging = true;
    dragButton = e.button;
    lastMouse = [e.clientX, e.clientY];
    mouseDownPos = [e.clientX, e.clientY];
    mouseDownTime = performance.now();
    e.preventDefault();
    // Hide hint on first interaction
    const hint = document.getElementById('viewport-hint');
    if (hint) hint.style.opacity = '0';
  });

  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - lastMouse[0];
    const dy = e.clientY - lastMouse[1];
    lastMouse = [e.clientX, e.clientY];

    if (dragButton === 0 && !e.shiftKey) {
      // Orbit
      camera.theta -= dx * 0.008;
      camera.phi -= dy * 0.008;
      camera.phi = Math.max(0.05, Math.min(Math.PI - 0.05, camera.phi));
    } else if (dragButton === 1 || dragButton === 2 || (dragButton === 0 && e.shiftKey)) {
      // Pan
      const camPos = getCameraPos();
      const forward = vnorm(vsub(camera.target, camPos));
      const right = vnorm(vcross(forward, [0, 1, 0]));
      const up = vcross(right, forward);
      const panSpeed = camera.distance * 0.002;
      camera.target = vadd(camera.target, vadd(vmul(right, -dx * panSpeed), vmul(up, dy * panSpeed)));
    }

    updateCamInfo();
    drawPreview();
  });

  window.addEventListener('mouseup', (e) => {
    const wasDragging = isDragging;
    isDragging = false;
    dragButton = -1;

    // Click-to-select: only if mouse didn't move much and was quick
    if (appMode === 'edit' && wasDragging) {
      const dx = e.clientX - mouseDownPos[0];
      const dy = e.clientY - mouseDownPos[1];
      const dist = Math.sqrt(dx*dx + dy*dy);
      const elapsed = performance.now() - mouseDownTime;
      if (dist < 5 && elapsed < 300 && e.button === 0) {
        handleViewportClick(e);
      }
    }
  });

  vp.addEventListener('wheel', (e) => {
    if (appMode !== 'edit') return;
    e.preventDefault();
    camera.distance *= 1 + e.deltaY * 0.001;
    camera.distance = Math.max(0.5, Math.min(50, camera.distance));
    updateCamInfo();
    drawPreview();
  }, { passive: false });

  vp.addEventListener('contextmenu', (e) => e.preventDefault());
}

// ============================================================
// Panel Toggle
// ============================================================
function togglePanel(header) {
  header.classList.toggle('collapsed');
  const body = header.nextElementSibling;
  body.classList.toggle('collapsed');
}

// ============================================================
// Wireframe Toggle
// ============================================================
function toggleWireframe() {
  wireframeMode = !wireframeMode;
  const btn = document.getElementById('btn-wireframe');
  if (wireframeMode) {
    btn.style.background = 'var(--accent-dim)';
    btn.style.borderColor = 'var(--accent)';
    btn.style.color = 'var(--accent)';
  } else {
    btn.style.background = '';
    btn.style.borderColor = '';
    btn.style.color = '';
  }
  drawPreview();
}

// ============================================================
// Click-to-Select via Raycasting
// ============================================================
function handleViewportClick(e) {
  const vp = document.getElementById('viewport');
  const rect = vp.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const W = previewCanvas.width;
  const H = previewCanvas.height;

  // Convert to normalized device coords
  const fovRad = camera.fov * Math.PI / 180;
  const aspect = W / H;
  const halfH = Math.tan(fovRad / 2);
  const halfW = halfH * aspect;

  const u = (2 * mx / W - 1) * halfW;
  const v = (1 - 2 * my / H) * halfH;

  const camPos = getCameraPos();
  const camDir = vnorm(vsub(camera.target, camPos));
  const camRight = vnorm(vcross(camDir, [0, 1, 0]));
  const camUp = vcross(camRight, camDir);
  const rd = vnorm(vadd(vadd(vmul(camRight, u), vmul(camUp, v)), camDir));

  // Intersect with all scene objects, find closest
  let closestT = Infinity;
  let closestIdx = -1;

  for (let i = 0; i < sceneObjects.length; i++) {
    const obj = sceneObjects[i];
    let hit;
    if (obj.type === 'sphere') {
      hit = intersectSphere(camPos, rd, obj.pos, obj.size);
    } else {
      hit = intersectBox(camPos, rd, obj.pos, obj.size);
    }
    if (hit && hit.t < closestT) {
      closestT = hit.t;
      closestIdx = i;
    }
  }

  selectedIndex = closestIdx;
  updateObjectList();
  loadProperties();
  drawPreview();

  // Scroll selected item into view in sidebar
  if (closestIdx >= 0) {
    const items = document.querySelectorAll('#object-list .obj-item');
    if (items[closestIdx]) {
      items[closestIdx].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }
}

// ============================================================
// Environment Presets
// ============================================================
function applyEnvironmentPreset(preset) {
  currentEnvPreset = preset;
  envRoomColor = null;
  envRoomEmission = null;
  envLights = [];

  switch (preset) {
    case 'default':
      skyIntensity = 1.5;
      sunPower = 10;
      break;
    case 'cornell':
      skyIntensity = 0;
      sunPower = 0;
      envRoomColor = { floor: [0.8, 0.8, 0.8], ceiling: [0.8, 0.8, 0.8], back: [0.8, 0.8, 0.8], left: [0.8, 0.2, 0.2], right: [0.2, 0.8, 0.2] };
      envRoomEmission = { ceiling: [8, 8, 7] };
      break;
    case 'sky':
      skyIntensity = 2.5;
      sunPower = 15;
      break;
    case 'studio':
      skyIntensity = 0.3;
      sunPower = 0;
      envLights = [
        { pos: [3, 4, 0], color: [12, 12, 14], radius: 0.5 },
        { pos: [-3, 4, 0], color: [12, 12, 14], radius: 0.5 },
        { pos: [0, 4, -5], color: [8, 8, 10], radius: 0.8 },
      ];
      break;
    case 'dark':
      skyIntensity = 0.05;
      sunPower = 0;
      envLights = [
        { pos: [3, 3, -2], color: [10, 2, 2], radius: 0.3 },
        { pos: [-3, 3, -4], color: [2, 2, 12], radius: 0.3 },
        { pos: [0, 4, -6], color: [2, 10, 4], radius: 0.3 },
      ];
      break;
  }

  document.getElementById('sky-intensity').value = skyIntensity;
  document.getElementById('sun-power').value = sunPower;
  drawPreview();
}

// ============================================================
// Object Management
// ============================================================
let objectCounter = 0;

function addSphere() {
  objectCounter++;
  sceneObjects.push({
    type: 'sphere',
    name: `Sphere ${objectCounter}`,
    pos: [0, 1, -3],
    size: 1,
    color: [0.53, 0.8, 1.0],
    colorHex: '#88ccff',
    ior: 1.5
  });
  selectedIndex = sceneObjects.length - 1;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function addCube() {
  objectCounter++;
  sceneObjects.push({
    type: 'cube',
    name: `Cube ${objectCounter}`,
    pos: [0, 0.8, -3],
    size: 0.8,
    color: [1.0, 0.6, 0.6],
    colorHex: '#ff9999',
    ior: 1.7
  });
  selectedIndex = sceneObjects.length - 1;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function duplicateSelected() {
  if (selectedIndex < 0 || selectedIndex >= sceneObjects.length) return;
  const src = sceneObjects[selectedIndex];
  objectCounter++;
  const dup = {
    ...src,
    name: src.name + ' copy',
    pos: [src.pos[0] + 1, src.pos[1], src.pos[2]],
    color: [...src.color],
  };
  sceneObjects.push(dup);
  selectedIndex = sceneObjects.length - 1;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function removeObject(idx, e) {
  if (e) e.stopPropagation();
  sceneObjects.splice(idx, 1);
  if (selectedIndex === idx) selectedIndex = -1;
  else if (selectedIndex > idx) selectedIndex--;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function selectObject(idx) {
  selectedIndex = idx;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function updateObjectList() {
  const ul = document.getElementById('object-list');
  document.getElementById('status-objects').textContent = `Objects: ${sceneObjects.length}`;

  if (sceneObjects.length === 0) {
    ul.innerHTML = '<li class="empty-msg">No objects — add one above</li>';
    return;
  }

  ul.innerHTML = sceneObjects.map((o, i) => {
    const icon = o.type === 'sphere' ? '●' : '■';
    const sel = i === selectedIndex ? ' selected' : '';
    return `<li class="obj-item${sel}" onclick="selectObject(${i})">
      <span class="obj-icon" style="background:${o.colorHex}30;color:${o.colorHex}">${icon}</span>
      <span class="obj-name">${o.name}</span>
      <span class="obj-type">${o.type}</span>
      <button class="obj-delete" onclick="removeObject(${i}, event)" title="Delete">✕</button>
    </li>`;
  }).join('');
}

function loadProperties() {
  const editor = document.getElementById('prop-editor');
  const noSel = document.getElementById('no-selection-msg');

  if (selectedIndex < 0 || selectedIndex >= sceneObjects.length) {
    editor.classList.add('hidden');
    noSel.classList.remove('hidden');
    return;
  }

  editor.classList.remove('hidden');
  noSel.classList.add('hidden');

  const o = sceneObjects[selectedIndex];
  document.getElementById('prop-px').value = o.pos[0];
  document.getElementById('prop-py').value = o.pos[1];
  document.getElementById('prop-pz').value = o.pos[2];
  document.getElementById('prop-size').value = o.size;
  document.getElementById('prop-size-slider').value = o.size;
  document.getElementById('size-val').textContent = o.size.toFixed(2);
  document.getElementById('prop-color').value = o.colorHex;
  document.getElementById('prop-ior').value = o.ior;
  document.getElementById('prop-ior-slider').value = o.ior;
  document.getElementById('ior-val').textContent = o.ior.toFixed(2);
}

function updateSelectedProp() {
  if (selectedIndex < 0 || selectedIndex >= sceneObjects.length) return;
  const o = sceneObjects[selectedIndex];
  o.pos[0] = parseFloat(document.getElementById('prop-px').value) || 0;
  o.pos[1] = parseFloat(document.getElementById('prop-py').value) || 0;
  o.pos[2] = parseFloat(document.getElementById('prop-pz').value) || 0;
  o.size = parseFloat(document.getElementById('prop-size').value) || 1;
  o.colorHex = document.getElementById('prop-color').value;
  o.color = hexToRgb(o.colorHex);
  o.ior = parseFloat(document.getElementById('prop-ior').value) || 1.5;
  updateObjectList();
  drawPreview();
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3), 16) / 255;
  const g = parseInt(hex.slice(3,5), 16) / 255;
  const b = parseInt(hex.slice(5,7), 16) / 255;
  return [r, g, b];
}

// ============================================================
// 3D Preview (Canvas 2D with perspective projection)
// ============================================================
const previewCanvas = document.getElementById('preview-canvas');
const previewCtx = previewCanvas.getContext('2d');

function resizePreview() {
  const vp = document.getElementById('viewport');
  previewCanvas.width = vp.clientWidth;
  previewCanvas.height = vp.clientHeight;
  previewCanvas.style.width = vp.clientWidth + 'px';
  previewCanvas.style.height = vp.clientHeight + 'px';
}

function project(point3d) {
  const camPos = getCameraPos();
  const forward = vnorm(vsub(camera.target, camPos));
  const right = vnorm(vcross(forward, [0, 1, 0]));
  const up = vcross(right, forward);

  const rel = vsub(point3d, camPos);
  const x = vdot(rel, right);
  const y = vdot(rel, up);
  const z = vdot(rel, forward);

  if (z <= 0.1) return null;

  const fovRad = camera.fov * Math.PI / 180;
  const f = 1 / Math.tan(fovRad / 2);
  const aspect = previewCanvas.width / previewCanvas.height;

  const sx = (x * f / z / aspect) * previewCanvas.width / 2 + previewCanvas.width / 2;
  const sy = (-y * f / z) * previewCanvas.height / 2 + previewCanvas.height / 2;

  return { x: sx, y: sy, z: z };
}

let lastFrameTime = 0;
function drawPreview() {
  if (appMode !== 'edit') return;
  const t0 = performance.now();
  resizePreview();
  const ctx = previewCtx;
  const W = previewCanvas.width;
  const H = previewCanvas.height;

  // Background gradient (varies by environment preset)
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  if (currentEnvPreset === 'cornell') {
    grad.addColorStop(0, '#2a1a1a');
    grad.addColorStop(0.5, '#1a1a1a');
    grad.addColorStop(1, '#1a1a1a');
  } else if (currentEnvPreset === 'sky') {
    grad.addColorStop(0, '#1a2a40');
    grad.addColorStop(0.4, '#2a3a55');
    grad.addColorStop(0.7, '#1a2535');
    grad.addColorStop(1, '#0a1520');
  } else if (currentEnvPreset === 'studio') {
    grad.addColorStop(0, '#181820');
    grad.addColorStop(0.5, '#1a1a24');
    grad.addColorStop(1, '#101018');
  } else if (currentEnvPreset === 'dark') {
    grad.addColorStop(0, '#050508');
    grad.addColorStop(0.5, '#080810');
    grad.addColorStop(1, '#030306');
  } else {
    grad.addColorStop(0, '#12121e');
    grad.addColorStop(0.4, '#141428');
    grad.addColorStop(0.7, '#101020');
    grad.addColorStop(1, '#0a0a14');
  }
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Subtle vignette
  const vignette = ctx.createRadialGradient(W/2, H/2, W*0.2, W/2, H/2, W*0.8);
  vignette.addColorStop(0, 'rgba(0,0,0,0)');
  vignette.addColorStop(1, 'rgba(0,0,0,0.3)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, W, H);

  // Draw ground grid (skip for Cornell Box)
  if (currentEnvPreset !== 'cornell') {
    drawGrid(ctx);
  }

  // Draw objects sorted by depth
  const camPos = getCameraPos();
  const sorted = sceneObjects.map((o, i) => ({
    obj: o, idx: i,
    depth: vlen(vsub(o.pos, camPos))
  })).sort((a, b) => b.depth - a.depth);

  for (const item of sorted) {
    drawObject(ctx, item.obj, item.idx);
  }

  // Draw axes indicator
  drawAxesIndicator(ctx);

  // Draw focus plane indicator (when aperture > 0)
  if (camera.aperture > 0) {
    drawFocusIndicator(ctx);
  }

  // Draw environment light indicators
  if (envLights.length > 0) {
    drawEnvLightIndicators(ctx);
  }

  // FPS counter
  const elapsed = performance.now() - t0;
  document.getElementById('status-fps').textContent = `${elapsed.toFixed(1)}ms`;

  // Update env preview
  drawEnvPreview();
}

function drawGrid(ctx) {
  const gridSize = 20;
  const gridStep = 1;

  for (let i = -gridSize; i <= gridSize; i += gridStep) {
    const isMajor = i % 5 === 0;
    const isAxis = i === 0;

    // Z-parallel lines
    const p1 = project([i, 0, -gridSize]);
    const p2 = project([i, 0, gridSize]);
    if (p1 && p2) {
      ctx.strokeStyle = isAxis ? 'rgba(96, 128, 224, 0.35)' : isMajor ? 'rgba(80, 80, 110, 0.2)' : 'rgba(60, 60, 80, 0.1)';
      ctx.lineWidth = isAxis ? 1.5 : isMajor ? 0.8 : 0.5;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    // X-parallel lines
    const p3 = project([-gridSize, 0, i]);
    const p4 = project([gridSize, 0, i]);
    if (p3 && p4) {
      ctx.strokeStyle = isAxis ? 'rgba(224, 96, 96, 0.35)' : isMajor ? 'rgba(80, 80, 110, 0.2)' : 'rgba(60, 60, 80, 0.1)';
      ctx.lineWidth = isAxis ? 1.5 : isMajor ? 0.8 : 0.5;
      ctx.beginPath();
      ctx.moveTo(p3.x, p3.y);
      ctx.lineTo(p4.x, p4.y);
      ctx.stroke();
    }
  }
}

function drawObject(ctx, obj, idx) {
  const isSelected = idx === selectedIndex;

  if (wireframeMode) {
    if (obj.type === 'sphere') {
      drawSphereWireframe(ctx, obj, isSelected);
    } else {
      drawCubeWireframe(ctx, obj, isSelected);
    }
  } else {
    if (obj.type === 'sphere') {
      drawSphere(ctx, obj, isSelected);
    } else {
      drawCube(ctx, obj, isSelected);
    }
  }
}

function drawSphereWireframe(ctx, obj, isSelected) {
  const center = project(obj.pos);
  if (!center) return;

  const edgePoint = project(vadd(obj.pos, [obj.size, 0, 0]));
  if (!edgePoint) return;
  const screenRadius = Math.abs(edgePoint.x - center.x);
  if (screenRadius < 1) return;

  const color = isSelected ? 'rgba(78, 154, 245, 0.9)' : obj.colorHex + 'aa';
  ctx.strokeStyle = color;
  ctx.lineWidth = isSelected ? 1.5 : 1;

  // Main circle
  ctx.beginPath();
  ctx.arc(center.x, center.y, screenRadius, 0, Math.PI * 2);
  ctx.stroke();

  // Latitude/longitude wireframe rings
  const rings = 3;
  for (let r = 1; r < rings; r++) {
    const angle = (r / rings) * Math.PI;
    const ringRadius = Math.sin(angle) * obj.size;
    const ringY = Math.cos(angle) * obj.size;
    const ringCenter = project(vadd(obj.pos, [0, ringY, 0]));
    const ringEdge = project(vadd(obj.pos, [ringRadius, ringY, 0]));
    if (ringCenter && ringEdge) {
      const sr = Math.abs(ringEdge.x - ringCenter.x);
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.ellipse(ringCenter.x, ringCenter.y, sr, sr * 0.3, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  }

  // Vertical ring
  const segments = 24;
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  for (let i = 0; i <= segments; i++) {
    const a = (i / segments) * Math.PI * 2;
    const p = project(vadd(obj.pos, [Math.sin(a) * obj.size, Math.cos(a) * obj.size, 0]));
    if (p) {
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
  }
  ctx.stroke();

  // Side ring
  ctx.beginPath();
  for (let i = 0; i <= segments; i++) {
    const a = (i / segments) * Math.PI * 2;
    const p = project(vadd(obj.pos, [0, Math.cos(a) * obj.size, Math.sin(a) * obj.size]));
    if (p) {
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
  }
  ctx.stroke();
  ctx.globalAlpha = 1;

  if (isSelected) {
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(center.x, center.y, screenRadius + 6, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(78, 154, 245, 0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

function drawCubeWireframe(ctx, obj, isSelected) {
  const s = obj.size;
  const corners = [
    [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
    [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]
  ].map(c => project(vadd(obj.pos, c)));

  if (corners.some(c => !c)) return;

  const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
  const color = isSelected ? 'rgba(78, 154, 245, 0.9)' : obj.colorHex + 'aa';
  ctx.strokeStyle = color;
  ctx.lineWidth = isSelected ? 1.5 : 1;

  for (const [a, b] of edges) {
    if (corners[a] && corners[b]) {
      ctx.beginPath();
      ctx.moveTo(corners[a].x, corners[a].y);
      ctx.lineTo(corners[b].x, corners[b].y);
      ctx.stroke();
    }
  }

  // Draw vertices
  ctx.fillStyle = color;
  for (const c of corners) {
    if (c) {
      ctx.beginPath();
      ctx.arc(c.x, c.y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  if (isSelected) {
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = 'rgba(78, 154, 245, 0.4)';
    ctx.lineWidth = 1;
    for (const [a, b] of edges) {
      if (corners[a] && corners[b]) {
        ctx.beginPath();
        ctx.moveTo(corners[a].x, corners[a].y);
        ctx.lineTo(corners[b].x, corners[b].y);
        ctx.stroke();
      }
    }
    ctx.setLineDash([]);
  }
}

function drawSphere(ctx, obj, isSelected) {
  const center = project(obj.pos);
  if (!center) return;

  const edgePoint = project(vadd(obj.pos, [obj.size, 0, 0]));
  if (!edgePoint) return;
  const screenRadius = Math.abs(edgePoint.x - center.x);
  if (screenRadius < 1) return;

  const camPos = getCameraPos();
  const lightDir = vnorm([0.5, 0.8, -0.3]);
  const toCamera = vnorm(vsub(camPos, obj.pos));
  const brightness = Math.max(0.2, vdot(toCamera, lightDir) * 0.5 + 0.5);

  const r = Math.floor(parseInt(obj.colorHex.slice(1,3), 16) * brightness);
  const g = Math.floor(parseInt(obj.colorHex.slice(3,5), 16) * brightness);
  const b = Math.floor(parseInt(obj.colorHex.slice(5,7), 16) * brightness);

  // Glass-like gradient
  const gradient = ctx.createRadialGradient(
    center.x - screenRadius * 0.3, center.y - screenRadius * 0.3, screenRadius * 0.05,
    center.x, center.y, screenRadius
  );
  gradient.addColorStop(0, `rgba(${Math.min(255, r + 100)}, ${Math.min(255, g + 100)}, ${Math.min(255, b + 100)}, 0.55)`);
  gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.3)`);
  gradient.addColorStop(0.85, `rgba(${r >> 1}, ${g >> 1}, ${b >> 1}, 0.2)`);
  gradient.addColorStop(1, `rgba(${r >> 2}, ${g >> 2}, ${b >> 2}, 0.15)`);

  ctx.beginPath();
  ctx.arc(center.x, center.y, screenRadius, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();

  // Edge highlight
  ctx.strokeStyle = isSelected ? 'rgba(78, 154, 245, 0.9)' : `rgba(${r}, ${g}, ${b}, 0.5)`;
  ctx.lineWidth = isSelected ? 2 : 1;
  ctx.stroke();

  // Specular highlight
  ctx.beginPath();
  ctx.arc(center.x - screenRadius * 0.25, center.y - screenRadius * 0.3, screenRadius * 0.12, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
  ctx.fill();

  // Secondary highlight
  ctx.beginPath();
  ctx.arc(center.x + screenRadius * 0.15, center.y + screenRadius * 0.2, screenRadius * 0.06, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
  ctx.fill();

  // Rim light
  ctx.beginPath();
  ctx.arc(center.x, center.y, screenRadius - 1, 0, Math.PI * 2);
  const rimGrad = ctx.createRadialGradient(center.x + screenRadius * 0.4, center.y + screenRadius * 0.3, 0, center.x, center.y, screenRadius);
  rimGrad.addColorStop(0, 'rgba(255,255,255,0)');
  rimGrad.addColorStop(0.8, 'rgba(255,255,255,0)');
  rimGrad.addColorStop(1, 'rgba(255,255,255,0.08)');
  ctx.fillStyle = rimGrad;
  ctx.fill();

  if (isSelected) {
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(center.x, center.y, screenRadius + 5, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(78, 154, 245, 0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

function drawCube(ctx, obj, isSelected) {
  const s = obj.size;
  const corners = [
    [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
    [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]
  ].map(c => project(vadd(obj.pos, c)));

  if (corners.some(c => !c)) return;

  const faces = [
    { verts: [0,1,2,3], normal: [0,0,-1] },
    { verts: [5,4,7,6], normal: [0,0,1] },
    { verts: [4,0,3,7], normal: [-1,0,0] },
    { verts: [1,5,6,2], normal: [1,0,0] },
    { verts: [3,2,6,7], normal: [0,1,0] },
    { verts: [4,5,1,0], normal: [0,-1,0] },
  ];

  const camPos = getCameraPos();
  const toCamera = vnorm(vsub(camPos, obj.pos));
  const lightDir = vnorm([0.5, 0.8, -0.3]);

  const sortedFaces = faces.map(f => {
    const avgZ = f.verts.reduce((s, v) => s + corners[v].z, 0) / 4;
    return { ...f, avgZ };
  }).sort((a, b) => b.avgZ - a.avgZ);

  const r0 = parseInt(obj.colorHex.slice(1,3), 16);
  const g0 = parseInt(obj.colorHex.slice(3,5), 16);
  const b0 = parseInt(obj.colorHex.slice(5,7), 16);

  for (const face of sortedFaces) {
    const dot = vdot(face.normal, toCamera);
    if (dot < -0.1) continue;

    const brightness = Math.max(0.15, vdot(face.normal, lightDir) * 0.4 + 0.4);
    const r = Math.floor(r0 * brightness);
    const g = Math.floor(g0 * brightness);
    const b = Math.floor(b0 * brightness);

    ctx.beginPath();
    const v0 = corners[face.verts[0]];
    ctx.moveTo(v0.x, v0.y);
    for (let i = 1; i < 4; i++) {
      const v = corners[face.verts[i]];
      ctx.lineTo(v.x, v.y);
    }
    ctx.closePath();
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
    ctx.fill();
    ctx.strokeStyle = isSelected ? 'rgba(78, 154, 245, 0.8)' : `rgba(${r}, ${g}, ${b}, 0.5)`;
    ctx.lineWidth = isSelected ? 1.5 : 0.8;
    ctx.stroke();
  }

  if (isSelected) {
    const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
    ctx.setLineDash([3, 3]);
    ctx.strokeStyle = 'rgba(78, 154, 245, 0.4)';
    ctx.lineWidth = 1;
    for (const [a, b] of edges) {
      if (corners[a] && corners[b]) {
        ctx.beginPath();
        ctx.moveTo(corners[a].x, corners[a].y);
        ctx.lineTo(corners[b].x, corners[b].y);
        ctx.stroke();
      }
    }
    ctx.setLineDash([]);
  }
}

function drawAxesIndicator(ctx) {
  const size = 40;
  const ox = 50, oy = previewCanvas.height - 50;

  // Background circle
  ctx.beginPath();
  ctx.arc(ox, oy, size + 8, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.stroke();

  const camPos = getCameraPos();
  const forward = vnorm(vsub(camera.target, camPos));
  const right = vnorm(vcross(forward, [0, 1, 0]));
  const up = vcross(right, forward);

  function projectAxis(dir) {
    const x = vdot(dir, right);
    const y = vdot(dir, up);
    return { x: ox + x * size, y: oy - y * size };
  }

  const axes = [
    { dir: [1, 0, 0], color: '#e06060', label: 'X' },
    { dir: [0, 1, 0], color: '#60c060', label: 'Y' },
    { dir: [0, 0, 1], color: '#6080e0', label: 'Z' },
  ];

  // Sort by depth so front axes draw on top
  const sortedAxes = axes.map(a => ({
    ...a,
    depth: vdot(a.dir, forward)
  })).sort((a, b) => a.depth - b.depth);

  for (const axis of sortedAxes) {
    const p = projectAxis(axis.dir);
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(p.x, p.y);
    ctx.strokeStyle = axis.color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = axis.depth > 0 ? 1 : 0.3;
    ctx.stroke();

    // Arrow tip
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fillStyle = axis.color;
    ctx.fill();

    ctx.fillStyle = axis.color;
    ctx.font = 'bold 10px sans-serif';
    const dx = p.x - ox, dy = p.y - oy;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len > 5) {
      ctx.fillText(axis.label, p.x + dx/len * 10 - 3, p.y + dy/len * 10 + 3);
    }
    ctx.globalAlpha = 1;
  }
}

function drawFocusIndicator(ctx) {
  // Draw a focus plane indicator as a dashed rectangle at the focus distance
  const camPos = getCameraPos();
  const camDir = vnorm(vsub(camera.target, camPos));
  const camRight = vnorm(vcross(camDir, [0, 1, 0]));
  const camUp = vcross(camRight, camDir);

  const focusCenter = vadd(camPos, vmul(camDir, camera.focusDist));
  const planeSize = camera.focusDist * Math.tan(camera.fov * Math.PI / 360) * 0.6;

  // Draw a diamond/rhombus shape at focus distance
  const points = [
    vadd(focusCenter, vmul(camRight, planeSize)),
    vadd(focusCenter, vmul(camUp, planeSize * 0.6)),
    vsub(focusCenter, vmul(camRight, planeSize)),
    vsub(focusCenter, vmul(camUp, planeSize * 0.6)),
  ];

  const projected = points.map(p => project(p)).filter(p => p !== null);
  if (projected.length < 4) return;

  // Draw focus plane
  ctx.save();
  ctx.setLineDash([6, 4]);
  ctx.strokeStyle = 'rgba(255, 200, 50, 0.5)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(projected[0].x, projected[0].y);
  for (let i = 1; i < projected.length; i++) {
    ctx.lineTo(projected[i].x, projected[i].y);
  }
  ctx.closePath();
  ctx.stroke();

  // Draw center crosshair
  const center = project(focusCenter);
  if (center) {
    ctx.setLineDash([]);
    ctx.strokeStyle = 'rgba(255, 200, 50, 0.7)';
    ctx.lineWidth = 1;
    const cs = 8;
    ctx.beginPath();
    ctx.moveTo(center.x - cs, center.y); ctx.lineTo(center.x + cs, center.y);
    ctx.moveTo(center.x, center.y - cs); ctx.lineTo(center.x, center.y + cs);
    ctx.stroke();

    // Label
    ctx.fillStyle = 'rgba(255, 200, 50, 0.8)';
    ctx.font = '10px sans-serif';
    ctx.fillText(`f:${camera.focusDist.toFixed(1)}`, center.x + 12, center.y - 6);
  }
  ctx.restore();
}

function drawEnvLightIndicators(ctx) {
  for (const light of envLights) {
    const p = project(light.pos);
    if (!p) continue;
    const r = Math.max(4, 20 / p.z);
    const col = light.color;
    const maxC = Math.max(col[0], col[1], col[2]);
    const nr = Math.min(255, col[0] / maxC * 255) | 0;
    const ng = Math.min(255, col[1] / maxC * 255) | 0;
    const nb = Math.min(255, col[2] / maxC * 255) | 0;

    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${nr}, ${ng}, ${nb}, 0.4)`;
    ctx.fill();
    ctx.strokeStyle = `rgba(${nr}, ${ng}, ${nb}, 0.8)`;
    ctx.lineWidth = 1;
    ctx.stroke();

    // Glow
    const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 3);
    glow.addColorStop(0, `rgba(${nr}, ${ng}, ${nb}, 0.15)`);
    glow.addColorStop(1, `rgba(${nr}, ${ng}, ${nb}, 0)`);
    ctx.beginPath();
    ctx.arc(p.x, p.y, r * 3, 0, Math.PI * 2);
    ctx.fillStyle = glow;
    ctx.fill();
  }
}

function drawEnvPreview() {
  const canvas = document.getElementById('env-preview');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  const W = canvas.width, H = canvas.height;

  for (let x = 0; x < W; x++) {
    const u = x / W;
    const rd = vnorm([u * 2 - 1, 0.3, -1]);
    const col = skyColor(rd);
    const r = Math.min(255, Math.pow(col[0] / (col[0] + 1), 1/2.2) * 255) | 0;
    const g = Math.min(255, Math.pow(col[1] / (col[1] + 1), 1/2.2) * 255) | 0;
    const b = Math.min(255, Math.pow(col[2] / (col[2] + 1), 1/2.2) * 255) | 0;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(x, 0, 1, H);
  }
}

// ============================================================
// Vector Math
// ============================================================
function v3(x,y,z) { return [x,y,z]; }
function vadd(a,b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
function vsub(a,b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function vmul(a,s) { return [a[0]*s, a[1]*s, a[2]*s]; }
function vmulv(a,b) { return [a[0]*b[0], a[1]*b[1], a[2]*b[2]]; }
function vdot(a,b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function vlen(a) { return Math.sqrt(vdot(a,a)); }
function vnorm(a) { const l=vlen(a); return l>0?vmul(a,1/l):[0,0,0]; }
function vcross(a,b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function vreflect(v,n) { return vsub(v, vmul(n, 2*vdot(v,n))); }
function vlerp(a,b,t) { return vadd(vmul(a,1-t), vmul(b,t)); }

// ============================================================
// Random
// ============================================================
function rand() { return Math.random(); }

function randomInUnitSphere() {
  while (true) {
    const p = [rand()*2-1, rand()*2-1, rand()*2-1];
    if (vdot(p,p) < 1) return p;
  }
}

function randomCosineDirection(n) {
  const r1 = rand(), r2 = rand();
  const phi = 2 * Math.PI * r1;
  const sqrtR2 = Math.sqrt(r2);
  const x = Math.cos(phi) * sqrtR2;
  const y = Math.sin(phi) * sqrtR2;
  const z = Math.sqrt(1 - r2);
  const w = n;
  const a = Math.abs(w[0]) > 0.9 ? v3(0,1,0) : v3(1,0,0);
  const u = vnorm(vcross(a, w));
  const v = vcross(w, u);
  return vnorm(vadd(vadd(vmul(u, x), vmul(v, y)), vmul(w, z)));
}

// ============================================================
// Ray-Object Intersection
// ============================================================
function intersectSphere(ro, rd, center, radius) {
  const oc = vsub(ro, center);
  const a = vdot(rd, rd);
  const b = vdot(oc, rd);
  const c = vdot(oc, oc) - radius * radius;
  const disc = b*b - a*c;
  if (disc < 0) return null;
  const sqrtDisc = Math.sqrt(disc);
  let t = (-b - sqrtDisc) / a;
  if (t < 0.001) {
    t = (-b + sqrtDisc) / a;
    if (t < 0.001) return null;
  }
  const p = vadd(ro, vmul(rd, t));
  const n = vnorm(vsub(p, center));
  return { t, p, n };
}

function intersectBox(ro, rd, center, halfSize) {
  const mn = vsub(center, [halfSize, halfSize, halfSize]);
  const mx = vadd(center, [halfSize, halfSize, halfSize]);
  let tmin = -Infinity, tmax = Infinity;
  let nmin = [0,0,0];

  for (let i = 0; i < 3; i++) {
    if (Math.abs(rd[i]) < 1e-8) {
      if (ro[i] < mn[i] || ro[i] > mx[i]) return null;
      continue;
    }
    const invD = 1 / rd[i];
    let t1 = (mn[i] - ro[i]) * invD;
    let t2 = (mx[i] - ro[i]) * invD;
    let n1 = [0,0,0]; n1[i] = -1;
    let n2 = [0,0,0]; n2[i] = 1;
    if (invD < 0) { [t1,t2] = [t2,t1]; [n1,n2] = [n2,n1]; }
    if (t1 > tmin) { tmin = t1; nmin = n1; }
    if (t2 < tmax) { tmax = t2; }
    if (tmin > tmax) return null;
  }

  let t = tmin;
  let n = nmin;
  if (t < 0.001) {
    t = tmax;
    let exitN = [0,0,0];
    for (let i = 0; i < 3; i++) {
      if (Math.abs(rd[i]) < 1e-8) continue;
      const invD = 1 / rd[i];
      let t2 = ((invD > 0 ? center[i]+halfSize : center[i]-halfSize) - ro[i]) * invD;
      if (Math.abs(t2 - tmax) < 0.0001) {
        exitN[i] = invD > 0 ? 1 : -1;
      }
    }
    n = exitN;
    if (t < 0.001) return null;
  }

  const p = vadd(ro, vmul(rd, t));
  return { t, p, n: vnorm(n) };
}

function intersectPlane(ro, rd, y) {
  if (Math.abs(rd[1]) < 1e-8) return null;
  const t = (y - ro[1]) / rd[1];
  if (t < 0.001) return null;
  const p = vadd(ro, vmul(rd, t));
  return { t, p, n: [0, 1, 0] };
}

// ============================================================
// Scene Intersection
// ============================================================
function intersectRoom(ro, rd) {
  // Cornell-box style room: 10x8x12 box centered around scene
  if (!envRoomColor) return null;
  const roomHalf = [5, 0, 6]; // half extents
  const roomCenter = [0, 4, -3];
  let closest = null;
  let closestT = Infinity;

  // Floor (y=0)
  if (Math.abs(rd[1]) > 1e-8) {
    const t = (0 - ro[1]) / rd[1];
    if (t > 0.001 && t < closestT) {
      closestT = t;
      closest = { t, p: vadd(ro, vmul(rd, t)), n: [0, 1, 0], material: 'room', albedo: envRoomColor.floor, emission: null };
    }
  }
  // Ceiling (y=8)
  if (Math.abs(rd[1]) > 1e-8) {
    const t = (8 - ro[1]) / rd[1];
    if (t > 0.001 && t < closestT) {
      closestT = t;
      const em = envRoomEmission && envRoomEmission.ceiling ? envRoomEmission.ceiling : null;
      closest = { t, p: vadd(ro, vmul(rd, t)), n: [0, -1, 0], material: 'room', albedo: envRoomColor.ceiling, emission: em };
    }
  }
  // Back wall (z=-9)
  if (Math.abs(rd[2]) > 1e-8) {
    const t = (-9 - ro[2]) / rd[2];
    if (t > 0.001 && t < closestT) {
      closestT = t;
      closest = { t, p: vadd(ro, vmul(rd, t)), n: [0, 0, 1], material: 'room', albedo: envRoomColor.back, emission: null };
    }
  }
  // Left wall (x=-5)
  if (Math.abs(rd[0]) > 1e-8) {
    const t = (-5 - ro[0]) / rd[0];
    if (t > 0.001 && t < closestT) {
      closestT = t;
      closest = { t, p: vadd(ro, vmul(rd, t)), n: [1, 0, 0], material: 'room', albedo: envRoomColor.left, emission: null };
    }
  }
  // Right wall (x=5)
  if (Math.abs(rd[0]) > 1e-8) {
    const t = (5 - ro[0]) / rd[0];
    if (t > 0.001 && t < closestT) {
      closestT = t;
      closest = { t, p: vadd(ro, vmul(rd, t)), n: [-1, 0, 0], material: 'room', albedo: envRoomColor.right, emission: null };
    }
  }
  return closest;
}

function intersectScene(ro, rd) {
  let closest = null;
  let closestT = Infinity;

  // Room walls (Cornell Box, etc.)
  const room = intersectRoom(ro, rd);
  if (room && room.t < closestT) {
    closestT = room.t;
    closest = room;
  }

  // Ground plane (only if no room)
  if (!envRoomColor) {
    const gnd = intersectPlane(ro, rd, 0);
    if (gnd && gnd.t < closestT) {
      closestT = gnd.t;
      closest = { ...gnd, material: 'ground' };
    }
  }

  // Environment lights as emissive spheres
  for (const light of envLights) {
    const hit = intersectSphere(ro, rd, light.pos, light.radius);
    if (hit && hit.t < closestT) {
      closestT = hit.t;
      closest = { ...hit, material: 'emissive', emission: light.color };
    }
  }

  for (const obj of sceneObjects) {
    let hit;
    if (obj.type === 'sphere') {
      hit = intersectSphere(ro, rd, obj.pos, obj.size);
    } else {
      hit = intersectBox(ro, rd, obj.pos, obj.size);
    }
    if (hit && hit.t < closestT) {
      closestT = hit.t;
      closest = { ...hit, material: 'glass', color: obj.color, ior: obj.ior };
    }
  }

  return closest;
}

// ============================================================
// Environment / Sky
// ============================================================
function skyColor(rd) {
  const t = 0.5 * (rd[1] + 1.0);
  const bottom = [0.8, 0.6, 0.4];
  const top = [0.3, 0.5, 0.9];
  const sky = vlerp(bottom, top, Math.max(0, Math.min(1, t)));
  const sunDir = vnorm([0.5, 0.8, -0.3]);
  const sunDot = Math.max(0, vdot(rd, sunDir));
  const sunGlow = Math.pow(sunDot, 128) * sunPower;
  const sunSoft = Math.pow(sunDot, 8) * 0.3;
  return vadd(vmul(sky, skyIntensity), vmul([1, 0.95, 0.8], sunGlow + sunSoft));
}

// ============================================================
// Fresnel (Schlick)
// ============================================================
function schlick(cosTheta, ior) {
  let r0 = (1 - ior) / (1 + ior);
  r0 = r0 * r0;
  return r0 + (1 - r0) * Math.pow(1 - cosTheta, 5);
}

// ============================================================
// Path Tracing
// ============================================================
function tracePath(ro, rd, maxBounces) {
  let throughput = [1, 1, 1];
  let color = [0, 0, 0];
  let curRo = ro, curRd = rd;

  for (let bounce = 0; bounce < maxBounces; bounce++) {
    const hit = intersectScene(curRo, curRd);

    if (!hit) {
      color = vadd(color, vmulv(throughput, skyColor(curRd)));
      break;
    }

    // Emissive light sources
    if (hit.material === 'emissive') {
      color = vadd(color, vmulv(throughput, hit.emission));
      break;
    }

    // Room walls (diffuse with optional emission)
    if (hit.material === 'room') {
      if (hit.emission) {
        color = vadd(color, vmulv(throughput, hit.emission));
        break;
      }
      throughput = vmulv(throughput, hit.albedo);
      curRo = vadd(hit.p, vmul(hit.n, 0.001));
      curRd = randomCosineDirection(hit.n);
      continue;
    }

    if (hit.material === 'ground') {
      const fx = Math.floor(hit.p[0] * 0.5);
      const fz = Math.floor(hit.p[2] * 0.5);
      const checker = ((fx + fz) & 1) === 0;
      const albedo = checker ? [0.4, 0.4, 0.45] : [0.2, 0.2, 0.22];
      throughput = vmulv(throughput, albedo);
      curRo = vadd(hit.p, vmul(hit.n, 0.001));
      curRd = randomCosineDirection(hit.n);
      continue;
    }

    if (hit.material === 'glass') {
      let n = hit.n;
      let eta;
      let frontFace = vdot(curRd, n) < 0;

      if (frontFace) {
        eta = 1.0 / hit.ior;
      } else {
        n = vmul(n, -1);
        eta = hit.ior;
      }

      const cosI = Math.min(-vdot(curRd, n), 1.0);
      const sin2T = eta * eta * (1 - cosI * cosI);

      if (!frontFace) {
        const dist = hit.t;
        const absorbColor = hit.color;
        const absorption = [
          Math.exp(-(1 - absorbColor[0]) * 2 * dist),
          Math.exp(-(1 - absorbColor[1]) * 2 * dist),
          Math.exp(-(1 - absorbColor[2]) * 2 * dist)
        ];
        throughput = vmulv(throughput, absorption);
      }

      const reflectance = schlick(cosI, eta);

      if (sin2T > 1.0 || rand() < reflectance) {
        curRd = vreflect(curRd, n);
        curRo = vadd(hit.p, vmul(n, 0.001));
      } else {
        const perpendicular = vmul(vadd(curRd, vmul(n, cosI)), eta);
        const parallel = vmul(n, -Math.sqrt(Math.abs(1 - vdot(perpendicular, perpendicular))));
        curRd = vnorm(vadd(perpendicular, parallel));
        curRo = vsub(hit.p, vmul(n, 0.001));
      }
      continue;
    }
  }

  return color;
}

// ============================================================
// Rendering
// ============================================================
const renderCanvas = document.getElementById('render-canvas');
const renderCtx = renderCanvas.getContext('2d');
let imgData;
let W, H;

function setupRenderCanvas() {
  const vp = document.getElementById('viewport');
  const scale = parseFloat(document.getElementById('res-scale').value);
  W = Math.floor(vp.clientWidth * scale);
  H = Math.floor(vp.clientHeight * scale);
  renderCanvas.width = W;
  renderCanvas.height = H;
  renderCanvas.style.width = vp.clientWidth + 'px';
  renderCanvas.style.height = vp.clientHeight + 'px';
  imgData = renderCtx.createImageData(W, H);
  accumBuffer = new Float64Array(W * H * 3);
  sampleCount = 0;
  document.getElementById('status-resolution').textContent = `${W}×${H}`;
}

function renderSample() {
  const fovRad = camera.fov * Math.PI / 180;
  const aspect = W / H;
  const camPos = getCameraPos();
  const camDir = vnorm(vsub(camera.target, camPos));
  const camRight = vnorm(vcross(camDir, [0, 1, 0]));
  const camUp = vcross(camRight, camDir);
  const halfH = Math.tan(fovRad / 2);
  const halfW = halfH * aspect;
  const maxBounces = parseInt(document.getElementById('max-bounces').value) || 8;
  const aperture = camera.aperture;
  const focusDist = camera.focusDist;

  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      const u = (2 * (x + rand()) / W - 1) * halfW;
      const v = (1 - 2 * (y + rand()) / H) * halfH;
      let rd = vnorm(vadd(vadd(vmul(camRight, u), vmul(camUp, v)), camDir));
      let ro = camPos;

      // Depth of field (thin lens model)
      if (aperture > 0) {
        const focusPoint = vadd(ro, vmul(rd, focusDist));
        const angle = rand() * Math.PI * 2;
        const radius = aperture * Math.sqrt(rand());
        const lensOffset = vadd(vmul(camRight, Math.cos(angle) * radius), vmul(camUp, Math.sin(angle) * radius));
        ro = vadd(camPos, lensOffset);
        rd = vnorm(vsub(focusPoint, ro));
      }

      const color = tracePath(ro, rd, maxBounces);
      const idx = (y * W + x) * 3;
      accumBuffer[idx] += color[0];
      accumBuffer[idx + 1] += color[1];
      accumBuffer[idx + 2] += color[2];
    }
  }

  sampleCount++;

  const invS = 1 / sampleCount;
  for (let i = 0; i < W * H; i++) {
    const r = accumBuffer[i * 3] * invS;
    const g = accumBuffer[i * 3 + 1] * invS;
    const b = accumBuffer[i * 3 + 2] * invS;
    imgData.data[i * 4] = Math.min(255, Math.pow(r / (r + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 1] = Math.min(255, Math.pow(g / (g + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 2] = Math.min(255, Math.pow(b / (b + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 3] = 255;
  }

  renderCtx.putImageData(imgData, 0, 0);

  const targetSpp = parseInt(document.getElementById('target-spp').value) || 100;
  const pct = Math.min(100, Math.round(sampleCount / targetSpp * 100));
  document.getElementById('progress-fill').style.width = pct + '%';
  document.getElementById('render-status-text').textContent = `${sampleCount} / ${targetSpp} spp (${pct}%)`;
  document.getElementById('status-text').textContent = `Rendering: ${sampleCount} spp`;

  if (sampleCount >= targetSpp) {
    finishRender();
  }
}

function renderLoop() {
  if (!rendering) return;
  const start = performance.now();
  renderSample();
  const elapsed = performance.now() - start;
  animFrameId = setTimeout(() => {
    if (rendering) renderLoop();
  }, Math.max(1, 16 - elapsed));
}

function switchToRenderMode() {
  appMode = 'render';
  previewCanvas.classList.add('hidden');
  renderCanvas.classList.remove('hidden');
  document.getElementById('render-overlay').classList.add('active');
  document.getElementById('btn-render').classList.add('hidden');
  document.getElementById('btn-stop').classList.remove('hidden');
  document.getElementById('btn-back').classList.remove('hidden');
  document.getElementById('mode-badge').textContent = 'RENDER';
  document.getElementById('mode-badge').classList.add('rendering');
  document.getElementById('status-dot').classList.remove('idle');
  document.getElementById('status-dot').classList.add('rendering');
  document.getElementById('viewport-hint').style.display = 'none';
}

function switchToEditMode() {
  appMode = 'edit';
  previewCanvas.classList.remove('hidden');
  renderCanvas.classList.add('hidden');
  document.getElementById('render-overlay').classList.remove('active');
  document.getElementById('btn-render').classList.remove('hidden');
  document.getElementById('btn-stop').classList.add('hidden');
  document.getElementById('btn-back').classList.add('hidden');
  document.getElementById('mode-badge').textContent = 'PREVIEW';
  document.getElementById('mode-badge').classList.remove('rendering');
  document.getElementById('status-dot').classList.add('idle');
  document.getElementById('status-dot').classList.remove('rendering');
  document.getElementById('status-text').textContent = 'Ready';
  document.getElementById('viewport-hint').style.display = '';
  drawPreview();
}

function startRender() {
  stopRender();
  switchToRenderMode();
  setupRenderCanvas();
  rendering = true;
  document.getElementById('status-text').textContent = 'Rendering...';
  renderLoop();
}

function stopRender() {
  rendering = false;
  if (animFrameId) {
    clearTimeout(animFrameId);
    animFrameId = null;
  }
  if (sampleCount > 0) {
    document.getElementById('status-text').textContent = `Stopped at ${sampleCount} spp`;
    document.getElementById('status-dot').classList.remove('rendering');
    document.getElementById('status-dot').classList.add('idle');
  }
}

function finishRender() {
  rendering = false;
  if (animFrameId) {
    clearTimeout(animFrameId);
    animFrameId = null;
  }
  document.getElementById('status-text').textContent = `Complete: ${sampleCount} spp`;
  document.getElementById('status-dot').classList.remove('rendering');
  document.getElementById('status-dot').classList.add('idle');
  document.getElementById('btn-stop').classList.add('hidden');
}

function backToEdit() {
  stopRender();
  switchToEditMode();
}

// ============================================================
// Keyboard Shortcuts
// ============================================================
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selectedIndex >= 0) removeObject(selectedIndex);
  }
  if (e.key === 'd' && e.ctrlKey) {
    e.preventDefault();
    duplicateSelected();
  }
  if (e.key === 'w') toggleWireframe();
  if (e.key === 'Escape') {
    if (appMode === 'render') backToEdit();
    else { selectedIndex = -1; updateObjectList(); loadProperties(); drawPreview(); }
  }
});

// ============================================================
// Default Scene
// ============================================================
function addDefaultScene() {
  objectCounter = 4;
  sceneObjects.push(
    { type: 'sphere', name: 'Sphere 1', pos: [0, 1, -4], size: 1, color: [0.9, 0.95, 1.0], colorHex: '#e6f0ff', ior: 1.5 },
    { type: 'sphere', name: 'Sphere 2', pos: [-2.2, 0.7, -3.5], size: 0.7, color: [0.5, 0.8, 1.0], colorHex: '#80ccff', ior: 1.45 },
    { type: 'cube', name: 'Cube 3', pos: [2, 0.8, -3.5], size: 0.8, color: [1.0, 0.6, 0.6], colorHex: '#ff9999', ior: 1.7 },
    { type: 'sphere', name: 'Sphere 4', pos: [0.8, 0.5, -2], size: 0.5, color: [0.6, 1.0, 0.6], colorHex: '#99ff99', ior: 1.3 }
  );
  selectedIndex = 0;
  updateObjectList();
  loadProperties();
}

// ============================================================
// Init
// ============================================================
addDefaultScene();
initCameraControls();
updateCamInfo();

window.addEventListener('resize', () => {
  if (appMode === 'edit') drawPreview();
  else if (rendering) startRender();
});

// Initial draw
requestAnimationFrame(() => drawPreview());
</script>
</body>
</html>
