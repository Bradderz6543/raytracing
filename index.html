<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Glass Path Tracer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  #sidebar {
    width: 320px;
    min-width: 320px;
    background: #16213e;
    border-right: 1px solid #0f3460;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }
  #sidebar h1 {
    font-size: 1.3em;
    padding: 16px 20px;
    background: #0f3460;
    color: #e94560;
    letter-spacing: 1px;
  }
  .section {
    padding: 16px 20px;
    border-bottom: 1px solid #0f3460;
  }
  .section h2 {
    font-size: 0.85em;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: #e94560;
    margin-bottom: 12px;
  }
  label {
    display: block;
    font-size: 0.8em;
    color: #8899aa;
    margin-bottom: 4px;
    margin-top: 8px;
  }
  label:first-child { margin-top: 0; }
  input[type="number"], input[type="color"], select {
    width: 100%;
    padding: 6px 10px;
    background: #1a1a2e;
    border: 1px solid #0f3460;
    color: #e0e0e0;
    border-radius: 4px;
    font-size: 0.9em;
  }
  input[type="color"] {
    height: 32px;
    padding: 2px;
    cursor: pointer;
  }
  select { cursor: pointer; }
  .row {
    display: flex;
    gap: 8px;
  }
  .row > div { flex: 1; }
  button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    font-weight: 600;
    transition: background 0.2s;
  }
  .btn-primary {
    background: #e94560;
    color: white;
    width: 100%;
    margin-top: 12px;
  }
  .btn-primary:hover { background: #c73650; }
  .btn-render {
    background: #4ecca3;
    color: #1a1a2e;
    width: 100%;
    margin-top: 12px;
    font-size: 1em;
    padding: 10px;
  }
  .btn-render:hover { background: #3db890; }
  .btn-stop {
    background: #e94560;
    color: white;
    width: 100%;
    margin-top: 8px;
    font-size: 1em;
    padding: 10px;
  }
  .btn-stop:hover { background: #c73650; }
  #object-list {
    list-style: none;
    max-height: 200px;
    overflow-y: auto;
  }
  #object-list li {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 8px;
    background: #1a1a2e;
    border-radius: 4px;
    margin-bottom: 4px;
    font-size: 0.85em;
  }
  #object-list li .obj-info {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #object-list li .color-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
  }
  .btn-remove {
    background: #e94560;
    color: white;
    padding: 2px 8px;
    font-size: 0.75em;
    border-radius: 3px;
  }
  .btn-remove:hover { background: #c73650; }
  #canvas-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #0d0d1a;
    position: relative;
  }
  canvas {
    image-rendering: pixelated;
  }
  #status {
    position: absolute;
    top: 12px;
    right: 16px;
    font-size: 0.8em;
    color: #4ecca3;
    background: rgba(0,0,0,0.6);
    padding: 4px 10px;
    border-radius: 4px;
  }
  .empty-msg {
    color: #556;
    font-size: 0.85em;
    font-style: italic;
  }
</style>
</head>
<body>

<div id="sidebar">
  <h1>ðŸ”® Glass Path Tracer</h1>

  <div class="section">
    <h2>Add Object</h2>
    <label>Type</label>
    <select id="obj-type">
      <option value="sphere">Sphere</option>
      <option value="cube">Cube</option>
    </select>

    <label>Position (X, Y, Z)</label>
    <div class="row">
      <div><input type="number" id="pos-x" value="0" step="0.5"></div>
      <div><input type="number" id="pos-y" value="1" step="0.5"></div>
      <div><input type="number" id="pos-z" value="-5" step="0.5"></div>
    </div>

    <label>Size</label>
    <input type="number" id="obj-size" value="1" step="0.1" min="0.1">

    <label>Color (absorption)</label>
    <input type="color" id="obj-color" value="#88ccff">

    <label>IOR (Index of Refraction)</label>
    <input type="number" id="obj-ior" value="1.5" step="0.05" min="1.0" max="3.0">

    <button class="btn-primary" onclick="addObject()">Add Object</button>
  </div>

  <div class="section">
    <h2>Scene Objects</h2>
    <ul id="object-list">
      <li class="empty-msg">No objects yet</li>
    </ul>
  </div>

  <div class="section">
    <h2>Render Settings</h2>
    <label>Resolution Scale</label>
    <select id="res-scale">
      <option value="0.25">Quarter (fast)</option>
      <option value="0.5" selected>Half</option>
      <option value="1">Full</option>
    </select>
    <label>Max Bounces</label>
    <input type="number" id="max-bounces" value="8" min="1" max="20">
    <button class="btn-render" onclick="startRender()">â–¶ Render</button>
    <button class="btn-stop" onclick="stopRender()">â–  Stop</button>
  </div>
</div>

<div id="canvas-container">
  <canvas id="canvas"></canvas>
  <div id="status">Ready</div>
</div>

<script>
// ============================================================
// Scene & State
// ============================================================
const sceneObjects = [];
let rendering = false;
let sampleCount = 0;
let accumBuffer = null;
let animFrameId = null;

function addObject() {
  const obj = {
    type: document.getElementById('obj-type').value,
    pos: [
      parseFloat(document.getElementById('pos-x').value),
      parseFloat(document.getElementById('pos-y').value),
      parseFloat(document.getElementById('pos-z').value)
    ],
    size: parseFloat(document.getElementById('obj-size').value),
    color: hexToRgb(document.getElementById('obj-color').value),
    colorHex: document.getElementById('obj-color').value,
    ior: parseFloat(document.getElementById('obj-ior').value)
  };
  sceneObjects.push(obj);
  updateObjectList();
}

function removeObject(idx) {
  sceneObjects.splice(idx, 1);
  updateObjectList();
}

function updateObjectList() {
  const ul = document.getElementById('object-list');
  if (sceneObjects.length === 0) {
    ul.innerHTML = '<li class="empty-msg">No objects yet</li>';
    return;
  }
  ul.innerHTML = sceneObjects.map((o, i) =>
    `<li>
      <span class="obj-info">
        <span class="color-dot" style="background:${o.colorHex}"></span>
        ${o.type} @ (${o.pos.map(v=>v.toFixed(1)).join(', ')}) s=${o.size.toFixed(1)} ior=${o.ior.toFixed(2)}
      </span>
      <button class="btn-remove" onclick="removeObject(${i})">âœ•</button>
    </li>`
  ).join('');
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3), 16) / 255;
  const g = parseInt(hex.slice(3,5), 16) / 255;
  const b = parseInt(hex.slice(5,7), 16) / 255;
  return [r, g, b];
}

// ============================================================
// Vector Math
// ============================================================
function v3(x,y,z) { return [x,y,z]; }
function vadd(a,b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
function vsub(a,b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function vmul(a,s) { return [a[0]*s, a[1]*s, a[2]*s]; }
function vmulv(a,b) { return [a[0]*b[0], a[1]*b[1], a[2]*b[2]]; }
function vdot(a,b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function vlen(a) { return Math.sqrt(vdot(a,a)); }
function vnorm(a) { const l=vlen(a); return l>0?vmul(a,1/l):[0,0,0]; }
function vcross(a,b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function vreflect(v,n) { return vsub(v, vmul(n, 2*vdot(v,n))); }
function vlerp(a,b,t) { return vadd(vmul(a,1-t), vmul(b,t)); }
function vabs(a) { return [Math.abs(a[0]), Math.abs(a[1]), Math.abs(a[2])]; }
function vmax(a,b) { return [Math.max(a[0],b[0]), Math.max(a[1],b[1]), Math.max(a[2],b[2])]; }
function vmin(a,b) { return [Math.min(a[0],b[0]), Math.min(a[1],b[1]), Math.min(a[2],b[2])]; }

// ============================================================
// Random
// ============================================================
function rand() { return Math.random(); }

function randomInUnitSphere() {
  while (true) {
    const p = [rand()*2-1, rand()*2-1, rand()*2-1];
    if (vdot(p,p) < 1) return p;
  }
}

function randomOnHemisphere(n) {
  const p = vnorm(randomInUnitSphere());
  return vdot(p, n) > 0 ? p : vmul(p, -1);
}

function randomCosineDirection(n) {
  // Cosine-weighted hemisphere sampling
  const r1 = rand(), r2 = rand();
  const phi = 2 * Math.PI * r1;
  const sqrtR2 = Math.sqrt(r2);
  const x = Math.cos(phi) * sqrtR2;
  const y = Math.sin(phi) * sqrtR2;
  const z = Math.sqrt(1 - r2);

  // Build ONB from normal
  const w = n;
  const a = Math.abs(w[0]) > 0.9 ? v3(0,1,0) : v3(1,0,0);
  const u = vnorm(vcross(a, w));
  const v = vcross(w, u);

  return vnorm(vadd(vadd(vmul(u, x), vmul(v, y)), vmul(w, z)));
}

// ============================================================
// Ray-Object Intersection
// ============================================================
function intersectSphere(ro, rd, center, radius) {
  const oc = vsub(ro, center);
  const a = vdot(rd, rd);
  const b = vdot(oc, rd);
  const c = vdot(oc, oc) - radius * radius;
  const disc = b*b - a*c;
  if (disc < 0) return null;
  const sqrtDisc = Math.sqrt(disc);
  let t = (-b - sqrtDisc) / a;
  if (t < 0.001) {
    t = (-b + sqrtDisc) / a;
    if (t < 0.001) return null;
  }
  const p = vadd(ro, vmul(rd, t));
  const n = vnorm(vsub(p, center));
  return { t, p, n };
}

function intersectBox(ro, rd, center, halfSize) {
  const mn = vsub(center, [halfSize, halfSize, halfSize]);
  const mx = vadd(center, [halfSize, halfSize, halfSize]);

  let tmin = -Infinity, tmax = Infinity;
  let nmin = [0,0,0];

  for (let i = 0; i < 3; i++) {
    if (Math.abs(rd[i]) < 1e-8) {
      if (ro[i] < mn[i] || ro[i] > mx[i]) return null;
      continue;
    }
    const invD = 1 / rd[i];
    let t1 = (mn[i] - ro[i]) * invD;
    let t2 = (mx[i] - ro[i]) * invD;
    let n1 = [0,0,0]; n1[i] = -1;
    let n2 = [0,0,0]; n2[i] = 1;
    if (invD < 0) { [t1,t2] = [t2,t1]; [n1,n2] = [n2,n1]; }
    if (t1 > tmin) { tmin = t1; nmin = n1; }
    if (t2 < tmax) { tmax = t2; }
    if (tmin > tmax) return null;
  }

  let t = tmin;
  let n = nmin;
  if (t < 0.001) {
    t = tmax;
    // Inside the box, flip normal
    // Recompute exit normal
    let exitN = [0,0,0];
    for (let i = 0; i < 3; i++) {
      if (Math.abs(rd[i]) < 1e-8) continue;
      const invD = 1 / rd[i];
      let t2 = ((invD > 0 ? center[i]+halfSize : center[i]-halfSize) - ro[i]) * invD;
      if (Math.abs(t2 - tmax) < 0.0001) {
        exitN[i] = invD > 0 ? 1 : -1;
      }
    }
    n = exitN;
    if (t < 0.001) return null;
  }

  const p = vadd(ro, vmul(rd, t));
  return { t, p, n: vnorm(n) };
}

function intersectPlane(ro, rd, y) {
  if (Math.abs(rd[1]) < 1e-8) return null;
  const t = (y - ro[1]) / rd[1];
  if (t < 0.001) return null;
  const p = vadd(ro, vmul(rd, t));
  return { t, p, n: [0, 1, 0] };
}

// ============================================================
// Scene Intersection
// ============================================================
function intersectScene(ro, rd) {
  let closest = null;
  let closestT = Infinity;

  // Ground plane at y=0
  const gnd = intersectPlane(ro, rd, 0);
  if (gnd && gnd.t < closestT) {
    closestT = gnd.t;
    closest = { ...gnd, material: 'ground' };
  }

  for (const obj of sceneObjects) {
    let hit;
    if (obj.type === 'sphere') {
      hit = intersectSphere(ro, rd, obj.pos, obj.size);
    } else {
      hit = intersectBox(ro, rd, obj.pos, obj.size);
    }
    if (hit && hit.t < closestT) {
      closestT = hit.t;
      closest = { ...hit, material: 'glass', color: obj.color, ior: obj.ior };
    }
  }

  return closest;
}

// ============================================================
// Environment / Sky
// ============================================================
function skyColor(rd) {
  const t = 0.5 * (rd[1] + 1.0);
  // Gradient from warm horizon to blue sky
  const bottom = [0.8, 0.6, 0.4];
  const top = [0.3, 0.5, 0.9];
  const sky = vlerp(bottom, top, Math.max(0, Math.min(1, t)));
  // Sun
  const sunDir = vnorm([0.5, 0.8, -0.3]);
  const sunDot = Math.max(0, vdot(rd, sunDir));
  const sunGlow = Math.pow(sunDot, 128) * 10;
  const sunSoft = Math.pow(sunDot, 8) * 0.3;
  return vadd(vmul(sky, 1.5), vmul([1, 0.95, 0.8], sunGlow + sunSoft));
}

// ============================================================
// Fresnel (Schlick)
// ============================================================
function schlick(cosTheta, ior) {
  let r0 = (1 - ior) / (1 + ior);
  r0 = r0 * r0;
  return r0 + (1 - r0) * Math.pow(1 - cosTheta, 5);
}

// ============================================================
// Path Tracing
// ============================================================
function tracePath(ro, rd, maxBounces) {
  let throughput = [1, 1, 1];
  let color = [0, 0, 0];
  let curRo = ro, curRd = rd;

  for (let bounce = 0; bounce < maxBounces; bounce++) {
    const hit = intersectScene(curRo, curRd);

    if (!hit) {
      // Hit sky
      color = vadd(color, vmulv(throughput, skyColor(curRd)));
      break;
    }

    if (hit.material === 'ground') {
      // Checkerboard pattern
      const fx = Math.floor(hit.p[0] * 0.5);
      const fz = Math.floor(hit.p[2] * 0.5);
      const checker = ((fx + fz) & 1) === 0;
      const albedo = checker ? [0.4, 0.4, 0.45] : [0.2, 0.2, 0.22];

      // Diffuse bounce
      throughput = vmulv(throughput, albedo);
      curRo = vadd(hit.p, vmul(hit.n, 0.001));
      curRd = randomCosineDirection(hit.n);
      continue;
    }

    if (hit.material === 'glass') {
      let n = hit.n;
      let eta;
      let frontFace = vdot(curRd, n) < 0;

      if (frontFace) {
        eta = 1.0 / hit.ior;
      } else {
        n = vmul(n, -1);
        eta = hit.ior;
      }

      const cosI = Math.min(-vdot(curRd, n), 1.0);
      const sin2T = eta * eta * (1 - cosI * cosI);

      // Beer's law absorption when exiting
      if (!frontFace) {
        // We traveled through the medium
        const dist = hit.t;
        const absorbColor = hit.color;
        // absorption = exp(-sigma * dist), sigma derived from color
        const absorption = [
          Math.exp(-(1 - absorbColor[0]) * 2 * dist),
          Math.exp(-(1 - absorbColor[1]) * 2 * dist),
          Math.exp(-(1 - absorbColor[2]) * 2 * dist)
        ];
        throughput = vmulv(throughput, absorption);
      }

      const reflectance = schlick(cosI, eta);

      if (sin2T > 1.0 || rand() < reflectance) {
        // Total internal reflection or Fresnel reflection
        curRd = vreflect(curRd, n);
        curRo = vadd(hit.p, vmul(n, 0.001));
      } else {
        // Refract (Snell's law)
        const perpendicular = vmul(vadd(curRd, vmul(n, cosI)), eta);
        const parallel = vmul(n, -Math.sqrt(Math.abs(1 - vdot(perpendicular, perpendicular))));
        curRd = vnorm(vadd(perpendicular, parallel));
        curRo = vsub(hit.p, vmul(n, 0.001));
      }
      continue;
    }
  }

  return color;
}

// ============================================================
// Rendering
// ============================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let imgData;
let W, H;

function setupCanvas() {
  const container = document.getElementById('canvas-container');
  const scale = parseFloat(document.getElementById('res-scale').value);
  W = Math.floor(container.clientWidth * scale);
  H = Math.floor(container.clientHeight * scale);
  canvas.width = W;
  canvas.height = H;
  canvas.style.width = container.clientWidth + 'px';
  canvas.style.height = container.clientHeight + 'px';
  imgData = ctx.createImageData(W, H);
  accumBuffer = new Float64Array(W * H * 3);
  sampleCount = 0;
}

function renderSample() {
  const fov = Math.PI / 3;
  const aspect = W / H;
  const camPos = [0, 2.5, 3];
  const camTarget = [0, 0.8, -3];
  const camDir = vnorm(vsub(camTarget, camPos));
  const camRight = vnorm(vcross(camDir, [0, 1, 0]));
  const camUp = vcross(camRight, camDir);
  const halfH = Math.tan(fov / 2);
  const halfW = halfH * aspect;
  const maxBounces = parseInt(document.getElementById('max-bounces').value) || 8;

  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      const u = (2 * (x + rand()) / W - 1) * halfW;
      const v = (1 - 2 * (y + rand()) / H) * halfH;

      const rd = vnorm(vadd(vadd(vmul(camRight, u), vmul(camUp, v)), camDir));
      const color = tracePath(camPos, rd, maxBounces);

      const idx = (y * W + x) * 3;
      accumBuffer[idx] += color[0];
      accumBuffer[idx + 1] += color[1];
      accumBuffer[idx + 2] += color[2];
    }
  }

  sampleCount++;

  // Tonemap and write to image
  const invS = 1 / sampleCount;
  for (let i = 0; i < W * H; i++) {
    const r = accumBuffer[i * 3] * invS;
    const g = accumBuffer[i * 3 + 1] * invS;
    const b = accumBuffer[i * 3 + 2] * invS;
    // ACES-ish tonemap + gamma
    imgData.data[i * 4] = Math.min(255, Math.pow(r / (r + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 1] = Math.min(255, Math.pow(g / (g + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 2] = Math.min(255, Math.pow(b / (b + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 3] = 255;
  }

  ctx.putImageData(imgData, 0, 0);
  document.getElementById('status').textContent = `Sample ${sampleCount} â€” progressive rendering`;
}

function renderLoop() {
  if (!rendering) return;
  const start = performance.now();
  renderSample();
  const elapsed = performance.now() - start;
  // Aim for responsive UI â€” yield between samples
  animFrameId = setTimeout(() => {
    if (rendering) renderLoop();
  }, Math.max(1, 16 - elapsed));
}

function startRender() {
  stopRender();
  setupCanvas();
  rendering = true;
  document.getElementById('status').textContent = 'Rendering...';
  renderLoop();
}

function stopRender() {
  rendering = false;
  if (animFrameId) {
    clearTimeout(animFrameId);
    animFrameId = null;
  }
  document.getElementById('status').textContent = sampleCount > 0 ? `Stopped at sample ${sampleCount}` : 'Ready';
}

// Add some default objects
function addDefaultScene() {
  sceneObjects.push(
    { type: 'sphere', pos: [0, 1, -4], size: 1, color: [0.9, 0.95, 1.0], colorHex: '#e6f0ff', ior: 1.5 },
    { type: 'sphere', pos: [-2.2, 0.7, -3.5], size: 0.7, color: [0.5, 0.8, 1.0], colorHex: '#80ccff', ior: 1.45 },
    { type: 'cube', pos: [2, 0.8, -3.5], size: 0.8, color: [1.0, 0.6, 0.6], colorHex: '#ff9999', ior: 1.7 },
    { type: 'sphere', pos: [0.8, 0.5, -2], size: 0.5, color: [0.6, 1.0, 0.6], colorHex: '#99ff99', ior: 1.3 }
  );
  updateObjectList();
}

addDefaultScene();

// Handle resize
window.addEventListener('resize', () => {
  if (rendering) startRender();
});
</script>
</body>
</html>
