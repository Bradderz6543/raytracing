<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Glass Path Tracer</title>
<style>
  :root {
    --bg-darkest: #111118;
    --bg-dark: #1a1a24;
    --bg-panel: #22222e;
    --bg-input: #2a2a38;
    --bg-hover: #32323f;
    --border: #3a3a4a;
    --border-light: #4a4a5a;
    --accent: #4e9af5;
    --accent-hover: #3a86e0;
    --accent-dim: #2a5a9a;
    --danger: #e94560;
    --danger-hover: #c73650;
    --success: #4ecca3;
    --success-hover: #3db890;
    --text: #d8d8e0;
    --text-dim: #8888a0;
    --text-muted: #5a5a70;
    --header-bg: #1e1e2a;
    --selected: rgba(78, 154, 245, 0.15);
    --selected-border: rgba(78, 154, 245, 0.5);
    --radius: 6px;
    --radius-sm: 4px;
    --transition: 0.15s ease;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', system-ui, sans-serif;
    background: var(--bg-darkest);
    color: var(--text);
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    font-size: 13px;
    -webkit-font-smoothing: antialiased;
  }

  /* ===== TOP TOOLBAR ===== */
  #toolbar {
    height: 42px;
    min-height: 42px;
    background: var(--header-bg);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 12px;
    gap: 8px;
    z-index: 100;
  }

  .toolbar-brand {
    font-weight: 700;
    font-size: 14px;
    color: var(--accent);
    margin-right: 16px;
    display: flex;
    align-items: center;
    gap: 6px;
    user-select: none;
  }

  .toolbar-brand svg { width: 18px; height: 18px; }

  .toolbar-divider {
    width: 1px;
    height: 24px;
    background: var(--border);
    margin: 0 4px;
  }

  .toolbar-group {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .toolbar-btn {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    color: var(--text);
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition);
    white-space: nowrap;
  }

  .toolbar-btn:hover {
    background: var(--bg-hover);
    border-color: var(--border-light);
  }

  .toolbar-btn svg { width: 14px; height: 14px; opacity: 0.8; }

  .toolbar-btn.primary {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }

  .toolbar-btn.primary:hover {
    background: var(--accent-hover);
    border-color: var(--accent-hover);
  }

  .toolbar-btn.render-btn {
    background: var(--success);
    border-color: var(--success);
    color: #111;
    font-weight: 700;
    padding: 5px 16px;
  }

  .toolbar-btn.render-btn:hover {
    background: var(--success-hover);
    border-color: var(--success-hover);
  }

  .toolbar-btn.stop-btn {
    background: var(--danger);
    border-color: var(--danger);
    color: #fff;
    font-weight: 700;
    padding: 5px 16px;
  }

  .toolbar-btn.stop-btn:hover {
    background: var(--danger-hover);
    border-color: var(--danger-hover);
  }

  .toolbar-btn.back-btn {
    background: var(--bg-input);
    border-color: var(--border);
    color: var(--text);
  }

  .toolbar-spacer { flex: 1; }

  .toolbar-info {
    font-size: 11px;
    color: var(--text-dim);
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .toolbar-info .cam-info {
    font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
    font-size: 10px;
    color: var(--text-muted);
    background: var(--bg-input);
    padding: 3px 8px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border);
  }

  .mode-badge {
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    padding: 3px 8px;
    border-radius: var(--radius-sm);
    background: var(--accent-dim);
    color: var(--accent);
  }

  .mode-badge.rendering {
    background: rgba(78, 204, 163, 0.2);
    color: var(--success);
  }

  /* ===== MAIN LAYOUT ===== */
  #main {
    flex: 1;
    display: flex;
    overflow: hidden;
  }

  /* ===== LEFT SIDEBAR ===== */
  #sidebar {
    width: 280px;
    min-width: 280px;
    background: var(--bg-panel);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    overflow-x: hidden;
  }

  .panel {
    border-bottom: 1px solid var(--border);
  }

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: var(--bg-dark);
    cursor: pointer;
    user-select: none;
    transition: background var(--transition);
  }

  .panel-header:hover { background: var(--bg-hover); }

  .panel-header h3 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    color: var(--text-dim);
  }

  .panel-header .arrow {
    font-size: 10px;
    color: var(--text-muted);
    transition: transform var(--transition);
  }

  .panel-header.collapsed .arrow { transform: rotate(-90deg); }

  .panel-body {
    padding: 10px 12px;
    overflow: hidden;
    transition: max-height 0.2s ease, padding 0.2s ease;
  }

  .panel-body.collapsed {
    max-height: 0 !important;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
  }

  /* ===== OBJECT LIST ===== */
  #object-list {
    list-style: none;
    max-height: 240px;
    overflow-y: auto;
  }

  #object-list::-webkit-scrollbar { width: 4px; }
  #object-list::-webkit-scrollbar-track { background: transparent; }
  #object-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .obj-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: all var(--transition);
    margin-bottom: 2px;
    border: 1px solid transparent;
  }

  .obj-item:hover { background: var(--bg-hover); }

  .obj-item.selected {
    background: var(--selected);
    border-color: var(--selected-border);
  }

  .obj-item .obj-icon {
    width: 24px;
    height: 24px;
    border-radius: var(--radius-sm);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    flex-shrink: 0;
  }

  .obj-item .obj-name {
    flex: 1;
    font-size: 12px;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .obj-item .obj-delete {
    opacity: 0;
    background: none;
    border: none;
    color: var(--danger);
    cursor: pointer;
    font-size: 14px;
    padding: 2px 4px;
    border-radius: 3px;
    transition: all var(--transition);
  }

  .obj-item:hover .obj-delete { opacity: 0.6; }
  .obj-item .obj-delete:hover { opacity: 1; background: rgba(233, 69, 96, 0.15); }

  .empty-msg {
    color: var(--text-muted);
    font-size: 11px;
    font-style: italic;
    padding: 8px 0;
    text-align: center;
  }

  /* ===== PROPERTIES PANEL ===== */
  .prop-group {
    margin-bottom: 10px;
  }

  .prop-group:last-child { margin-bottom: 0; }

  .prop-label {
    display: block;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-muted);
    margin-bottom: 4px;
  }

  .prop-row {
    display: flex;
    gap: 4px;
    align-items: center;
  }

  .prop-row .axis-label {
    font-size: 10px;
    font-weight: 700;
    width: 14px;
    text-align: center;
    flex-shrink: 0;
  }

  .axis-x { color: #e06060; }
  .axis-y { color: #60c060; }
  .axis-z { color: #6080e0; }

  input[type="number"],
  input[type="text"],
  select {
    width: 100%;
    padding: 5px 8px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: var(--radius-sm);
    font-size: 12px;
    font-family: inherit;
    outline: none;
    transition: border-color var(--transition);
  }

  input[type="number"]:focus,
  input[type="text"]:focus,
  select:focus {
    border-color: var(--accent);
  }

  input[type="number"] {
    -moz-appearance: textfield;
    font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
    font-size: 11px;
  }

  input[type="number"]::-webkit-inner-spin-button,
  input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
  }

  input[type="color"] {
    width: 100%;
    height: 28px;
    padding: 2px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    cursor: pointer;
    outline: none;
  }

  input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
  input[type="color"]::-webkit-color-swatch { border: none; border-radius: 2px; }

  select {
    cursor: pointer;
    -webkit-appearance: none;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%235a5a70'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    padding-right: 24px;
  }

  /* Custom range slider */
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    margin: 6px 0;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--bg-panel);
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  }

  /* ===== VIEWPORT ===== */
  #viewport {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-darkest);
    position: relative;
    overflow: hidden;
  }

  #viewport canvas {
    image-rendering: auto;
  }

  #viewport canvas.pixelated {
    image-rendering: pixelated;
  }

  /* ===== STATUS BAR ===== */
  #statusbar {
    height: 24px;
    min-height: 24px;
    background: var(--header-bg);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 12px;
    font-size: 11px;
    color: var(--text-muted);
    gap: 16px;
  }

  .status-item {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--success);
  }

  .status-dot.idle { background: var(--text-muted); }
  .status-dot.rendering { background: var(--success); animation: pulse 1s infinite; }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  /* ===== RENDER OVERLAY ===== */
  #render-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 10;
  }

  #render-overlay.active { display: flex; }

  .render-progress {
    position: absolute;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.75);
    backdrop-filter: blur(8px);
    padding: 8px 16px;
    border-radius: var(--radius);
    border: 1px solid var(--border);
    font-size: 12px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 12px;
    pointer-events: auto;
  }

  .progress-bar {
    width: 120px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-bar-fill {
    height: 100%;
    background: var(--success);
    border-radius: 2px;
    transition: width 0.3s ease;
  }

  /* ===== NO SELECTION STATE ===== */
  .no-selection {
    color: var(--text-muted);
    font-size: 11px;
    font-style: italic;
    text-align: center;
    padding: 12px 0;
  }

  /* ===== SCROLLBAR ===== */
  #sidebar::-webkit-scrollbar { width: 4px; }
  #sidebar::-webkit-scrollbar-track { background: transparent; }
  #sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  /* ===== HIDDEN ===== */
  .hidden { display: none !important; }

  /* ===== RENDER SETTINGS INLINE ===== */
  .settings-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
  }

  .settings-row label {
    font-size: 11px;
    color: var(--text-dim);
    white-space: nowrap;
    min-width: 70px;
  }

  .settings-row input, .settings-row select {
    flex: 1;
  }

  .slider-value {
    font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
    font-size: 10px;
    color: var(--text-muted);
    min-width: 32px;
    text-align: right;
  }

  /* ===== ROOM SELECTOR ===== */
  .room-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 4px;
  }

  .room-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    color: var(--text);
    font-size: 11px;
    cursor: pointer;
    transition: all var(--transition);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .room-btn:hover {
    background: var(--bg-hover);
    border-color: var(--border-light);
  }

  .room-btn.active {
    background: var(--selected);
    border-color: var(--selected-border);
    color: var(--accent);
  }

  .room-btn .room-icon {
    font-size: 14px;
    flex-shrink: 0;
  }
</style>
</head>
<body>

<!-- ===== TOP TOOLBAR ===== -->
<div id="toolbar">
  <div class="toolbar-brand">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="10"/><path d="M8 12l2-6 4 10 2-4"/>
    </svg>
    Glass Path Tracer
  </div>

  <div class="toolbar-divider"></div>

  <div class="toolbar-group" id="edit-tools">
    <button class="toolbar-btn" onclick="addSphere()" title="Add Glass Sphere">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="8"/></svg>
      Sphere
    </button>
    <button class="toolbar-btn" onclick="addCube()" title="Add Glass Cube">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16" rx="1"/></svg>
      Cube
    </button>
  </div>

  <div class="toolbar-divider"></div>

  <div class="toolbar-group">
    <button class="toolbar-btn render-btn" id="btn-render" onclick="startRender()">‚ñ∂ Render</button>
    <button class="toolbar-btn stop-btn hidden" id="btn-stop" onclick="stopRender()">‚ñ† Stop</button>
    <button class="toolbar-btn back-btn hidden" id="btn-back" onclick="backToEdit()">‚Üê Edit</button>
  </div>

  <div class="toolbar-spacer"></div>

  <div class="toolbar-info">
    <span class="mode-badge" id="mode-badge">EDIT</span>
    <span class="cam-info" id="cam-info">cam: 0.0, 2.5, 3.0</span>
  </div>
</div>

<!-- ===== MAIN AREA ===== -->
<div id="main">

  <!-- LEFT SIDEBAR -->
  <div id="sidebar">

    <!-- ENVIRONMENT / ROOM -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>Environment</h3>
        <span class="arrow">‚ñº</span>
      </div>
      <div class="panel-body">
        <div class="room-grid" id="room-grid">
          <button class="room-btn active" onclick="switchRoom('default')" data-room="default">
            <span class="room-icon">üè†</span> Default
          </button>
          <button class="room-btn" onclick="switchRoom('cornell')" data-room="cornell">
            <span class="room-icon">üü•</span> Cornell Box
          </button>
          <button class="room-btn" onclick="switchRoom('outdoor')" data-room="outdoor">
            <span class="room-icon">üå§Ô∏è</span> Open Sky
          </button>
          <button class="room-btn" onclick="switchRoom('studio')" data-room="studio">
            <span class="room-icon">üí°</span> Studio
          </button>
          <button class="room-btn" onclick="switchRoom('darkroom')" data-room="darkroom">
            <span class="room-icon">üåà</span> Dark Room
          </button>
        </div>
      </div>
    </div>

    <!-- SCENE OBJECTS -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>Scene Objects</h3>
        <span class="arrow">‚ñº</span>
      </div>
      <div class="panel-body">
        <ul id="object-list">
          <li class="empty-msg">No objects ‚Äî add one above</li>
        </ul>
      </div>
    </div>

    <!-- PROPERTIES -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>Properties</h3>
        <span class="arrow">‚ñº</span>
      </div>
      <div class="panel-body" id="properties-panel">
        <div class="no-selection" id="no-selection-msg">Select an object to edit</div>
        <div id="prop-editor" class="hidden">
          <div class="prop-group">
            <span class="prop-label">Position</span>
            <div class="prop-row">
              <span class="axis-label axis-x">X</span>
              <input type="number" id="prop-px" step="0.1" onchange="updateSelectedProp()">
              <span class="axis-label axis-y">Y</span>
              <input type="number" id="prop-py" step="0.1" onchange="updateSelectedProp()">
              <span class="axis-label axis-z">Z</span>
              <input type="number" id="prop-pz" step="0.1" onchange="updateSelectedProp()">
            </div>
          </div>
          <div class="prop-group">
            <span class="prop-label">Size</span>
            <input type="range" id="prop-size-slider" min="0.1" max="3" step="0.05" oninput="document.getElementById('prop-size').value=this.value; updateSelectedProp()">
            <input type="number" id="prop-size" step="0.05" min="0.1" max="5" onchange="document.getElementById('prop-size-slider').value=this.value; updateSelectedProp()">
          </div>
          <div class="prop-group">
            <span class="prop-label">Color / Tint</span>
            <input type="color" id="prop-color" onchange="updateSelectedProp()">
          </div>
          <div class="prop-group">
            <span class="prop-label">IOR (Index of Refraction)</span>
            <input type="range" id="prop-ior-slider" min="1.0" max="3.0" step="0.01" oninput="document.getElementById('prop-ior').value=this.value; updateSelectedProp()">
            <input type="number" id="prop-ior" step="0.01" min="1.0" max="3.0" onchange="document.getElementById('prop-ior-slider').value=this.value; updateSelectedProp()">
          </div>
        </div>
      </div>
    </div>

    <!-- RENDER SETTINGS -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>Render Settings</h3>
        <span class="arrow">‚ñº</span>
      </div>
      <div class="panel-body">
        <div class="settings-row">
          <label>Resolution</label>
          <select id="res-scale">
            <option value="0.25">Quarter</option>
            <option value="0.5" selected>Half</option>
            <option value="1">Full</option>
          </select>
        </div>
        <div class="settings-row">
          <label>Bounces</label>
          <input type="number" id="max-bounces" value="8" min="1" max="20">
        </div>
        <div class="settings-row">
          <label>Target SPP</label>
          <input type="number" id="target-spp" value="100" min="1" max="10000">
        </div>
      </div>
    </div>

    <!-- CAMERA -->
    <div class="panel">
      <div class="panel-header" onclick="togglePanel(this)">
        <h3>Camera</h3>
        <span class="arrow">‚ñº</span>
      </div>
      <div class="panel-body">
        <div class="settings-row">
          <label>FOV</label>
          <input type="range" id="cam-fov" min="20" max="120" value="60" step="1" oninput="camera.fov=+this.value; drawPreview()">
        </div>
        <div class="settings-row">
          <label>Focus Dist</label>
          <input type="range" id="cam-focus-dist" min="0.5" max="30" value="5" step="0.1" oninput="camera.focusDist=+this.value; document.getElementById('focus-dist-val').textContent=this.value; drawPreview()">
          <span class="slider-value" id="focus-dist-val">5</span>
        </div>
        <div class="settings-row">
          <label>Aperture</label>
          <input type="range" id="cam-aperture" min="0" max="1" value="0.05" step="0.005" oninput="camera.aperture=+this.value; document.getElementById('aperture-val').textContent=(+this.value).toFixed(3); drawPreview()">
          <span class="slider-value" id="aperture-val">0.050</span>
        </div>
        <div class="settings-row">
          <label>Reset</label>
          <button class="toolbar-btn" onclick="resetCamera()" style="font-size:11px;padding:3px 10px;">Reset Camera</button>
        </div>
      </div>
    </div>

  </div>

  <!-- VIEWPORT -->
  <div id="viewport">
    <canvas id="preview-canvas"></canvas>
    <canvas id="render-canvas" class="hidden pixelated"></canvas>
    <div id="render-overlay">
      <div class="render-progress">
        <div class="progress-bar"><div class="progress-bar-fill" id="progress-fill"></div></div>
        <span id="render-status-text">0 / 100 spp</span>
      </div>
    </div>
  </div>

</div>

<!-- ===== STATUS BAR ===== -->
<div id="statusbar">
  <div class="status-item">
    <div class="status-dot idle" id="status-dot"></div>
    <span id="status-text">Ready</span>
  </div>
  <div class="status-item" id="status-objects">Objects: 0</div>
  <div class="status-item" id="status-resolution"></div>
  <div class="status-item" id="status-room">Room: Default</div>
</div>

<script>
// ============================================================
// Scene & State
// ============================================================
const sceneObjects = [];
let selectedIndex = -1;
let appMode = 'edit'; // 'edit' or 'render'
let rendering = false;
let sampleCount = 0;
let accumBuffer = null;
let animFrameId = null;
let currentRoom = 'default';

// ============================================================
// Room / Environment Presets
// ============================================================
const roomPresets = {
  default: {
    name: 'Default',
    sky: function(rd) {
      const t = 0.5 * (rd[1] + 1.0);
      const bottom = [0.8, 0.6, 0.4];
      const top = [0.3, 0.5, 0.9];
      const sky = vlerp(bottom, top, Math.max(0, Math.min(1, t)));
      const sunDir = vnorm([0.5, 0.8, -0.3]);
      const sunDot = Math.max(0, vdot(rd, sunDir));
      const sunGlow = Math.pow(sunDot, 128) * 10;
      const sunSoft = Math.pow(sunDot, 8) * 0.3;
      return vadd(vmul(sky, 1.5), vmul([1, 0.95, 0.8], sunGlow + sunSoft));
    },
    ground: function(p) {
      const fx = Math.floor(p[0] * 0.5);
      const fz = Math.floor(p[2] * 0.5);
      const checker = ((fx + fz) & 1) === 0;
      return checker ? [0.4, 0.4, 0.45] : [0.2, 0.2, 0.22];
    },
    walls: null,
    previewBg: function(ctx, W, H) {
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, '#1a1a2e');
      grad.addColorStop(0.5, '#16213e');
      grad.addColorStop(1, '#0d0d1a');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
    },
    lights: []
  },
  cornell: {
    name: 'Cornell Box',
    sky: function(rd) {
      return [0, 0, 0]; // enclosed box, no sky
    },
    ground: function(p) {
      return [0.73, 0.73, 0.73]; // white floor
    },
    walls: [
      // Left wall (red)
      { plane: 'x', val: -5, dir: 1, color: [0.65, 0.05, 0.05], min: [-5, 0, -10], max: [-5, 8, 2] },
      // Right wall (green)
      { plane: 'x', val: 5, dir: -1, color: [0.12, 0.45, 0.15], min: [5, 0, -10], max: [5, 8, 2] },
      // Back wall (white)
      { plane: 'z', val: -8, dir: 1, color: [0.73, 0.73, 0.73], min: [-5, 0, -8], max: [5, 8, -8] },
      // Ceiling (white) with light
      { plane: 'y', val: 8, dir: -1, color: [0.73, 0.73, 0.73], min: [-5, 8, -10], max: [5, 8, 2] },
    ],
    ceilingLight: { center: [0, 7.99, -3], size: 2, emission: [15, 15, 13] },
    previewBg: function(ctx, W, H) {
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, '#2a1a1a');
      grad.addColorStop(0.5, '#1a2a1a');
      grad.addColorStop(1, '#1a1a1a');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
    },
    lights: [{ pos: [0, 7.5, -3], color: [15, 15, 13], radius: 2 }]
  },
  outdoor: {
    name: 'Open Sky',
    sky: function(rd) {
      const t = 0.5 * (rd[1] + 1.0);
      const horizon = [0.9, 0.85, 0.7];
      const zenith = [0.15, 0.35, 0.85];
      const sky = vlerp(horizon, zenith, Math.pow(Math.max(0, Math.min(1, t)), 0.6));
      const sunDir = vnorm([0.3, 0.6, -0.5]);
      const sunDot = Math.max(0, vdot(rd, sunDir));
      const sunGlow = Math.pow(sunDot, 256) * 20;
      const sunSoft = Math.pow(sunDot, 4) * 0.5;
      const groundGlow = rd[1] < 0 ? 0.3 * Math.pow(1 + rd[1], 2) : 0;
      return vadd(vadd(vmul(sky, 2.0), vmul([1, 0.95, 0.85], sunGlow + sunSoft)), [groundGlow, groundGlow * 0.8, groundGlow * 0.5]);
    },
    ground: function(p) {
      // Grass-like ground
      const noise = Math.sin(p[0] * 3.7) * Math.cos(p[2] * 2.3) * 0.05;
      return [0.15 + noise, 0.35 + noise, 0.1 + noise];
    },
    walls: null,
    previewBg: function(ctx, W, H) {
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, '#1a3060');
      grad.addColorStop(0.4, '#3a5a80');
      grad.addColorStop(0.5, '#8a9ab0');
      grad.addColorStop(0.6, '#2a4020');
      grad.addColorStop(1, '#1a2a10');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
    },
    lights: []
  },
  studio: {
    name: 'Studio',
    sky: function(rd) {
      // Soft studio environment
      const t = 0.5 * (rd[1] + 1.0);
      const base = vlerp([0.15, 0.15, 0.18], [0.25, 0.25, 0.3], t);
      // Key light (front-right, warm)
      const keyDir = vnorm([0.6, 0.5, 0.3]);
      const keyDot = Math.max(0, vdot(rd, keyDir));
      const key = Math.pow(keyDot, 32) * 5;
      // Fill light (front-left, cool)
      const fillDir = vnorm([-0.5, 0.3, 0.4]);
      const fillDot = Math.max(0, vdot(rd, fillDir));
      const fill = Math.pow(fillDot, 16) * 2;
      // Rim light (behind, bright)
      const rimDir = vnorm([0, 0.4, -0.8]);
      const rimDot = Math.max(0, vdot(rd, rimDir));
      const rim = Math.pow(rimDot, 64) * 8;
      return vadd(vadd(vadd(base, vmul([1, 0.9, 0.7], key)), vmul([0.5, 0.6, 1], fill)), vmul([1, 1, 1], rim));
    },
    ground: function(p) {
      // Smooth studio floor
      const d = Math.sqrt(p[0] * p[0] + p[2] * p[2]);
      const v = Math.max(0.1, 0.35 - d * 0.01);
      return [v, v, v + 0.02];
    },
    walls: null,
    previewBg: function(ctx, W, H) {
      const grad = ctx.createRadialGradient(W * 0.5, H * 0.4, 0, W * 0.5, H * 0.4, W * 0.7);
      grad.addColorStop(0, '#2a2a35');
      grad.addColorStop(1, '#111118');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
    },
    lights: []
  },
  darkroom: {
    name: 'Dark Room',
    sky: function(rd) {
      // Very dark with colored point lights
      const base = [0.01, 0.01, 0.02];
      // Red light (left)
      const redDir = vnorm([-0.7, 0.3, -0.3]);
      const redDot = Math.max(0, vdot(rd, redDir));
      const red = Math.pow(redDot, 48) * 8;
      // Blue light (right)
      const blueDir = vnorm([0.7, 0.2, -0.4]);
      const blueDot = Math.max(0, vdot(rd, blueDir));
      const blue = Math.pow(blueDot, 48) * 8;
      // Purple light (top)
      const purpDir = vnorm([0, 0.8, -0.2]);
      const purpDot = Math.max(0, vdot(rd, purpDir));
      const purp = Math.pow(purpDot, 64) * 6;
      // Green accent (behind)
      const greenDir = vnorm([0.2, 0.1, 0.9]);
      const greenDot = Math.max(0, vdot(rd, greenDir));
      const green = Math.pow(greenDot, 32) * 3;
      return vadd(vadd(vadd(vadd(base, vmul([1, 0.1, 0.05], red)), vmul([0.05, 0.15, 1], blue)), vmul([0.6, 0.1, 0.8], purp)), vmul([0.05, 0.8, 0.2], green));
    },
    ground: function(p) {
      return [0.03, 0.03, 0.05];
    },
    walls: [
      // Enclosing dark walls
      { plane: 'x', val: -6, dir: 1, color: [0.05, 0.05, 0.08], min: [-6, 0, -12], max: [-6, 8, 4] },
      { plane: 'x', val: 6, dir: -1, color: [0.05, 0.05, 0.08], min: [6, 0, -12], max: [6, 8, 4] },
      { plane: 'z', val: -10, dir: 1, color: [0.05, 0.05, 0.08], min: [-6, 0, -10], max: [6, 8, -10] },
      { plane: 'y', val: 8, dir: -1, color: [0.05, 0.05, 0.08], min: [-6, 8, -12], max: [6, 8, 4] },
    ],
    previewBg: function(ctx, W, H) {
      const grad = ctx.createLinearGradient(0, 0, W, H);
      grad.addColorStop(0, '#1a0520');
      grad.addColorStop(0.3, '#050515');
      grad.addColorStop(0.7, '#051020');
      grad.addColorStop(1, '#100510');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
    },
    lights: []
  }
};

function switchRoom(roomId) {
  currentRoom = roomId;
  // Update button states
  document.querySelectorAll('.room-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.room === roomId);
  });
  document.getElementById('status-room').textContent = `Room: ${roomPresets[roomId].name}`;
  drawPreview();
}

// ============================================================
// Camera (orbit camera)
// ============================================================
const camera = {
  target: [0, 0.8, -3],
  distance: 8,
  theta: 0.3,   // horizontal angle
  phi: 0.45,    // vertical angle (from top)
  fov: 60,
  panX: 0,
  panY: 0,
  focusDist: 5,
  aperture: 0.05,
};

function getCameraPos() {
  const sinP = Math.sin(camera.phi);
  const cosP = Math.cos(camera.phi);
  const sinT = Math.sin(camera.theta);
  const cosT = Math.cos(camera.theta);
  return [
    camera.target[0] + camera.distance * sinP * sinT,
    camera.target[1] + camera.distance * cosP,
    camera.target[2] + camera.distance * sinP * cosT
  ];
}

function resetCamera() {
  camera.target = [0, 0.8, -3];
  camera.distance = 8;
  camera.theta = 0.3;
  camera.phi = 0.45;
  camera.fov = 60;
  camera.focusDist = 5;
  camera.aperture = 0.05;
  document.getElementById('cam-fov').value = 60;
  document.getElementById('cam-focus-dist').value = 5;
  document.getElementById('focus-dist-val').textContent = '5';
  document.getElementById('cam-aperture').value = 0.05;
  document.getElementById('aperture-val').textContent = '0.050';
  updateCamInfo();
  drawPreview();
}

function updateCamInfo() {
  const p = getCameraPos();
  document.getElementById('cam-info').textContent =
    `cam: ${p[0].toFixed(1)}, ${p[1].toFixed(1)}, ${p[2].toFixed(1)}`;
}

// ============================================================
// Camera Controls
// ============================================================
let isDragging = false;
let dragButton = -1;
let lastMouse = [0, 0];
let clickStartPos = [0, 0];
let clickMoved = false;

function initCameraControls() {
  const vp = document.getElementById('viewport');

  vp.addEventListener('mousedown', (e) => {
    if (appMode !== 'edit') return;
    isDragging = true;
    dragButton = e.button;
    lastMouse = [e.clientX, e.clientY];
    clickStartPos = [e.clientX, e.clientY];
    clickMoved = false;
    e.preventDefault();
  });

  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - lastMouse[0];
    const dy = e.clientY - lastMouse[1];
    lastMouse = [e.clientX, e.clientY];

    // Track if mouse moved significantly (for click-to-select)
    const totalDx = e.clientX - clickStartPos[0];
    const totalDy = e.clientY - clickStartPos[1];
    if (Math.abs(totalDx) > 3 || Math.abs(totalDy) > 3) {
      clickMoved = true;
    }

    if (dragButton === 0 && !e.shiftKey) {
      // Orbit
      camera.theta -= dx * 0.008;
      camera.phi -= dy * 0.008;
      camera.phi = Math.max(0.05, Math.min(Math.PI - 0.05, camera.phi));
    } else if (dragButton === 2 || (dragButton === 0 && e.shiftKey)) {
      // Pan
      const camPos = getCameraPos();
      const forward = vnorm(vsub(camera.target, camPos));
      const right = vnorm(vcross(forward, [0, 1, 0]));
      const up = vcross(right, forward);
      const panSpeed = camera.distance * 0.002;
      camera.target = vadd(camera.target, vadd(vmul(right, -dx * panSpeed), vmul(up, dy * panSpeed)));
    }

    updateCamInfo();
    drawPreview();
  });

  window.addEventListener('mouseup', (e) => {
    if (isDragging && dragButton === 0 && !clickMoved && appMode === 'edit') {
      // Click without drag ‚Äî try to select object
      handleClickSelect(e);
    }
    isDragging = false;
    dragButton = -1;
  });

  vp.addEventListener('wheel', (e) => {
    if (appMode !== 'edit') return;
    e.preventDefault();
    camera.distance *= 1 + e.deltaY * 0.001;
    camera.distance = Math.max(1, Math.min(50, camera.distance));
    updateCamInfo();
    drawPreview();
  }, { passive: false });

  vp.addEventListener('contextmenu', (e) => e.preventDefault());
}

// ============================================================
// Click-to-Select (raycasting from mouse position)
// ============================================================
function handleClickSelect(e) {
  const vp = document.getElementById('viewport');
  const rect = vp.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const W = previewCanvas.width;
  const H = previewCanvas.height;

  // Convert to normalized device coords
  const ndcX = (2 * mx / W - 1);
  const ndcY = (1 - 2 * my / H);

  const fovRad = camera.fov * Math.PI / 180;
  const aspect = W / H;
  const halfH = Math.tan(fovRad / 2);
  const halfW = halfH * aspect;

  const camPos = getCameraPos();
  const camDir = vnorm(vsub(camera.target, camPos));
  const camRight = vnorm(vcross(camDir, [0, 1, 0]));
  const camUp = vcross(camRight, camDir);

  const rd = vnorm(vadd(vadd(vmul(camRight, ndcX * halfW), vmul(camUp, ndcY * halfH)), camDir));

  // Test intersection with each scene object
  let closestIdx = -1;
  let closestT = Infinity;

  for (let i = 0; i < sceneObjects.length; i++) {
    const obj = sceneObjects[i];
    let hit;
    if (obj.type === 'sphere') {
      hit = intersectSphere(camPos, rd, obj.pos, obj.size);
    } else {
      hit = intersectBox(camPos, rd, obj.pos, obj.size);
    }
    if (hit && hit.t < closestT) {
      closestT = hit.t;
      closestIdx = i;
    }
  }

  if (closestIdx >= 0) {
    selectObject(closestIdx);
  } else {
    // Clicked on nothing ‚Äî deselect
    selectedIndex = -1;
    updateObjectList();
    loadProperties();
    drawPreview();
  }
}

// ============================================================
// Panel Toggle
// ============================================================
function togglePanel(header) {
  header.classList.toggle('collapsed');
  const body = header.nextElementSibling;
  body.classList.toggle('collapsed');
}

// ============================================================
// Object Management
// ============================================================
function addSphere() {
  sceneObjects.push({
    type: 'sphere',
    pos: [0, 1, -3],
    size: 1,
    color: [0.53, 0.8, 1.0],
    colorHex: '#88ccff',
    ior: 1.5
  });
  selectedIndex = sceneObjects.length - 1;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function addCube() {
  sceneObjects.push({
    type: 'cube',
    pos: [0, 0.8, -3],
    size: 0.8,
    color: [1.0, 0.6, 0.6],
    colorHex: '#ff9999',
    ior: 1.7
  });
  selectedIndex = sceneObjects.length - 1;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function removeObject(idx, e) {
  if (e) e.stopPropagation();
  sceneObjects.splice(idx, 1);
  if (selectedIndex === idx) selectedIndex = -1;
  else if (selectedIndex > idx) selectedIndex--;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function selectObject(idx) {
  selectedIndex = idx;
  updateObjectList();
  loadProperties();
  drawPreview();
}

function updateObjectList() {
  const ul = document.getElementById('object-list');
  document.getElementById('status-objects').textContent = `Objects: ${sceneObjects.length}`;

  if (sceneObjects.length === 0) {
    ul.innerHTML = '<li class="empty-msg">No objects ‚Äî add one above</li>';
    return;
  }

  ul.innerHTML = sceneObjects.map((o, i) => {
    const icon = o.type === 'sphere' ? '‚óè' : '‚ñ†';
    const sel = i === selectedIndex ? ' selected' : '';
    return `<li class="obj-item${sel}" onclick="selectObject(${i})">
      <span class="obj-icon" style="background:${o.colorHex}40;color:${o.colorHex}">${icon}</span>
      <span class="obj-name">${o.type.charAt(0).toUpperCase() + o.type.slice(1)} ${i + 1}</span>
      <button class="obj-delete" onclick="removeObject(${i}, event)" title="Delete">‚úï</button>
    </li>`;
  }).join('');
}

function loadProperties() {
  const editor = document.getElementById('prop-editor');
  const noSel = document.getElementById('no-selection-msg');

  if (selectedIndex < 0 || selectedIndex >= sceneObjects.length) {
    editor.classList.add('hidden');
    noSel.classList.remove('hidden');
    return;
  }

  editor.classList.remove('hidden');
  noSel.classList.add('hidden');

  const o = sceneObjects[selectedIndex];
  document.getElementById('prop-px').value = o.pos[0];
  document.getElementById('prop-py').value = o.pos[1];
  document.getElementById('prop-pz').value = o.pos[2];
  document.getElementById('prop-size').value = o.size;
  document.getElementById('prop-size-slider').value = o.size;
  document.getElementById('prop-color').value = o.colorHex;
  document.getElementById('prop-ior').value = o.ior;
  document.getElementById('prop-ior-slider').value = o.ior;
}

function updateSelectedProp() {
  if (selectedIndex < 0 || selectedIndex >= sceneObjects.length) return;
  const o = sceneObjects[selectedIndex];
  o.pos[0] = parseFloat(document.getElementById('prop-px').value) || 0;
  o.pos[1] = parseFloat(document.getElementById('prop-py').value) || 0;
  o.pos[2] = parseFloat(document.getElementById('prop-pz').value) || 0;
  o.size = parseFloat(document.getElementById('prop-size').value) || 1;
  o.colorHex = document.getElementById('prop-color').value;
  o.color = hexToRgb(o.colorHex);
  o.ior = parseFloat(document.getElementById('prop-ior').value) || 1.5;
  updateObjectList();
  drawPreview();
}

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3), 16) / 255;
  const g = parseInt(hex.slice(3,5), 16) / 255;
  const b = parseInt(hex.slice(5,7), 16) / 255;
  return [r, g, b];
}

// ============================================================
// 3D Preview (Canvas 2D with perspective projection)
// ============================================================
const previewCanvas = document.getElementById('preview-canvas');
const previewCtx = previewCanvas.getContext('2d');

function resizePreview() {
  const vp = document.getElementById('viewport');
  previewCanvas.width = vp.clientWidth;
  previewCanvas.height = vp.clientHeight;
  previewCanvas.style.width = vp.clientWidth + 'px';
  previewCanvas.style.height = vp.clientHeight + 'px';
}

function project(point3d) {
  const camPos = getCameraPos();
  const forward = vnorm(vsub(camera.target, camPos));
  const right = vnorm(vcross(forward, [0, 1, 0]));
  const up = vcross(right, forward);

  const rel = vsub(point3d, camPos);
  const x = vdot(rel, right);
  const y = vdot(rel, up);
  const z = vdot(rel, forward);

  if (z <= 0.1) return null;

  const fovRad = camera.fov * Math.PI / 180;
  const f = 1 / Math.tan(fovRad / 2);
  const aspect = previewCanvas.width / previewCanvas.height;

  const sx = (x * f / z / aspect) * previewCanvas.width / 2 + previewCanvas.width / 2;
  const sy = (-y * f / z) * previewCanvas.height / 2 + previewCanvas.height / 2;

  return { x: sx, y: sy, z: z };
}

function drawPreview() {
  if (appMode !== 'edit') return;
  resizePreview();
  const ctx = previewCtx;
  const W = previewCanvas.width;
  const H = previewCanvas.height;

  // Background from room preset
  const room = roomPresets[currentRoom];
  room.previewBg(ctx, W, H);

  // Draw room walls in preview if applicable
  if (room.walls) {
    drawRoomWalls(ctx, room);
  }

  // Draw ground grid
  drawGrid(ctx);

  // Draw focus indicator
  drawFocusIndicator(ctx);

  // Draw objects sorted by depth
  const camPos = getCameraPos();
  const sorted = sceneObjects.map((o, i) => ({
    obj: o, idx: i,
    depth: vlen(vsub(o.pos, camPos))
  })).sort((a, b) => b.depth - a.depth);

  for (const item of sorted) {
    drawObject(ctx, item.obj, item.idx);
  }

  // Draw ceiling light indicator for cornell box
  if (room.ceilingLight) {
    drawLightIndicator(ctx, room.ceilingLight);
  }

  // Draw axes indicator
  drawAxesIndicator(ctx);
}

function drawFocusIndicator(ctx) {
  const camPos = getCameraPos();
  const camDir = vnorm(vsub(camera.target, camPos));
  const camRight = vnorm(vcross(camDir, [0, 1, 0]));
  const camUp = vcross(camRight, camDir);

  const focusCenter = vadd(camPos, vmul(camDir, camera.focusDist));
  const focusProj = project(focusCenter);
  if (!focusProj) return;

  // Draw a crosshair + circle at the focus distance
  const indicatorRadius = 0.8;
  const segments = 24;

  // Draw translucent circle in 3D
  ctx.beginPath();
  let firstPoint = null;
  for (let i = 0; i <= segments; i++) {
    const angle = (i / segments) * Math.PI * 2;
    const worldPt = vadd(focusCenter,
      vadd(vmul(camRight, Math.cos(angle) * indicatorRadius),
           vmul(camUp, Math.sin(angle) * indicatorRadius)));
    const sp = project(worldPt);
    if (!sp) continue;
    if (!firstPoint) {
      ctx.moveTo(sp.x, sp.y);
      firstPoint = sp;
    } else {
      ctx.lineTo(sp.x, sp.y);
    }
  }
  ctx.strokeStyle = 'rgba(255, 200, 50, 0.5)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([4, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Draw crosshair at center
  const crossSize = 12;
  ctx.beginPath();
  ctx.moveTo(focusProj.x - crossSize, focusProj.y);
  ctx.lineTo(focusProj.x + crossSize, focusProj.y);
  ctx.moveTo(focusProj.x, focusProj.y - crossSize);
  ctx.lineTo(focusProj.x, focusProj.y + crossSize);
  ctx.strokeStyle = 'rgba(255, 200, 50, 0.8)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Label
  ctx.fillStyle = 'rgba(255, 200, 50, 0.7)';
  ctx.font = '10px sans-serif';
  ctx.fillText(`f:${camera.focusDist.toFixed(1)}`, focusProj.x + 14, focusProj.y - 6);
}

function drawRoomWalls(ctx, room) {
  if (!room.walls) return;
  const camPos = getCameraPos();

  for (const wall of room.walls) {
    // Generate 4 corners of the wall
    let corners;
    if (wall.plane === 'x') {
      corners = [
        [wall.val, wall.min[1], wall.min[2]],
        [wall.val, wall.min[1], wall.max[2]],
        [wall.val, wall.max[1], wall.max[2]],
        [wall.val, wall.max[1], wall.min[2]],
      ];
    } else if (wall.plane === 'y') {
      corners = [
        [wall.min[0], wall.val, wall.min[2]],
        [wall.max[0], wall.val, wall.min[2]],
        [wall.max[0], wall.val, wall.max[2]],
        [wall.min[0], wall.val, wall.max[2]],
      ];
    } else {
      corners = [
        [wall.min[0], wall.min[1], wall.val],
        [wall.max[0], wall.min[1], wall.val],
        [wall.max[0], wall.max[1], wall.val],
        [wall.min[0], wall.max[1], wall.val],
      ];
    }

    const projected = corners.map(c => project(c));
    if (projected.some(p => !p)) continue;

    const r = Math.floor(wall.color[0] * 255 * 0.4);
    const g = Math.floor(wall.color[1] * 255 * 0.4);
    const b = Math.floor(wall.color[2] * 255 * 0.4);

    ctx.beginPath();
    ctx.moveTo(projected[0].x, projected[0].y);
    for (let i = 1; i < 4; i++) {
      ctx.lineTo(projected[i].x, projected[i].y);
    }
    ctx.closePath();
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
    ctx.fill();
    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }
}

function drawLightIndicator(ctx, light) {
  const p = project(light.center);
  if (!p) return;
  const s = light.size;
  const edge = project(vadd(light.center, [s, 0, 0]));
  if (!edge) return;
  const screenSize = Math.abs(edge.x - p.x);

  ctx.beginPath();
  ctx.rect(p.x - screenSize, p.y - screenSize, screenSize * 2, screenSize * 2);
  ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255, 255, 200, 0.6)';
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.fillStyle = 'rgba(255, 255, 200, 0.5)';
  ctx.font = '9px sans-serif';
  ctx.fillText('üí° Light', p.x - 20, p.y + 4);
}

function drawGrid(ctx) {
  const gridSize = 20;
  const gridStep = 1;
  ctx.lineWidth = 1;

  for (let i = -gridSize; i <= gridSize; i += gridStep) {
    const p1 = project([i, 0, -gridSize]);
    const p2 = project([i, 0, gridSize]);
    if (p1 && p2) {
      ctx.strokeStyle = i === 0 ? 'rgba(96, 128, 224, 0.3)' : 'rgba(80, 80, 100, 0.15)';
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    const p3 = project([-gridSize, 0, i]);
    const p4 = project([gridSize, 0, i]);
    if (p3 && p4) {
      ctx.strokeStyle = i === 0 ? 'rgba(224, 96, 96, 0.3)' : 'rgba(80, 80, 100, 0.15)';
      ctx.beginPath();
      ctx.moveTo(p3.x, p3.y);
      ctx.lineTo(p4.x, p4.y);
      ctx.stroke();
    }
  }
}

function drawObject(ctx, obj, idx) {
  const isSelected = idx === selectedIndex;

  if (obj.type === 'sphere') {
    drawSphere(ctx, obj, isSelected);
  } else {
    drawCube(ctx, obj, isSelected);
  }
}

function drawSphere(ctx, obj, isSelected) {
  const center = project(obj.pos);
  if (!center) return;

  // Approximate screen radius
  const edgePoint = project(vadd(obj.pos, [obj.size, 0, 0]));
  if (!edgePoint) return;
  const screenRadius = Math.abs(edgePoint.x - center.x);
  if (screenRadius < 1) return;

  // Flat shaded sphere
  const camPos = getCameraPos();
  const lightDir = vnorm([0.5, 0.8, -0.3]);
  const toCamera = vnorm(vsub(camPos, obj.pos));
  const brightness = Math.max(0.2, vdot(toCamera, lightDir) * 0.5 + 0.5);

  const r = Math.floor(parseInt(obj.colorHex.slice(1,3), 16) * brightness);
  const g = Math.floor(parseInt(obj.colorHex.slice(3,5), 16) * brightness);
  const b = Math.floor(parseInt(obj.colorHex.slice(5,7), 16) * brightness);

  // Glass-like gradient
  const gradient = ctx.createRadialGradient(
    center.x - screenRadius * 0.3, center.y - screenRadius * 0.3, screenRadius * 0.1,
    center.x, center.y, screenRadius
  );
  gradient.addColorStop(0, `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 0.6)`);
  gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.35)`);
  gradient.addColorStop(1, `rgba(${r >> 1}, ${g >> 1}, ${b >> 1}, 0.2)`);

  ctx.beginPath();
  ctx.arc(center.x, center.y, screenRadius, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();

  // Edge highlight
  ctx.strokeStyle = isSelected ? 'rgba(78, 154, 245, 0.9)' : `rgba(${r}, ${g}, ${b}, 0.5)`;
  ctx.lineWidth = isSelected ? 2.5 : 1;
  ctx.stroke();

  // Specular highlight
  ctx.beginPath();
  ctx.arc(center.x - screenRadius * 0.25, center.y - screenRadius * 0.25, screenRadius * 0.15, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.fill();

  if (isSelected) {
    // Glow effect
    ctx.shadowColor = 'rgba(78, 154, 245, 0.6)';
    ctx.shadowBlur = 15;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(center.x, center.y, screenRadius + 5, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(78, 154, 245, 0.7)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowBlur = 0;
  }
}

function drawCube(ctx, obj, isSelected) {
  const s = obj.size;
  // 8 corners of the cube
  const corners = [
    [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
    [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]
  ].map(c => project(vadd(obj.pos, c)));

  if (corners.some(c => !c)) return;

  const faces = [
    { verts: [0,1,2,3], normal: [0,0,-1] },
    { verts: [5,4,7,6], normal: [0,0,1] },
    { verts: [4,0,3,7], normal: [-1,0,0] },
    { verts: [1,5,6,2], normal: [1,0,0] },
    { verts: [3,2,6,7], normal: [0,1,0] },
    { verts: [4,5,1,0], normal: [0,-1,0] },
  ];

  const camPos = getCameraPos();
  const toCamera = vnorm(vsub(camPos, obj.pos));
  const lightDir = vnorm([0.5, 0.8, -0.3]);

  // Sort faces back to front
  const sortedFaces = faces.map(f => {
    const avgZ = f.verts.reduce((s, v) => s + corners[v].z, 0) / 4;
    return { ...f, avgZ };
  }).sort((a, b) => b.avgZ - a.avgZ);

  const r0 = parseInt(obj.colorHex.slice(1,3), 16);
  const g0 = parseInt(obj.colorHex.slice(3,5), 16);
  const b0 = parseInt(obj.colorHex.slice(5,7), 16);

  for (const face of sortedFaces) {
    // Check if face is visible
    const dot = vdot(face.normal, toCamera);
    if (dot < -0.1) continue;

    const brightness = Math.max(0.15, vdot(face.normal, lightDir) * 0.4 + 0.4);
    const r = Math.floor(r0 * brightness);
    const g = Math.floor(g0 * brightness);
    const b = Math.floor(b0 * brightness);

    ctx.beginPath();
    const v0 = corners[face.verts[0]];
    ctx.moveTo(v0.x, v0.y);
    for (let i = 1; i < 4; i++) {
      const v = corners[face.verts[i]];
      ctx.lineTo(v.x, v.y);
    }
    ctx.closePath();
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.35)`;
    ctx.fill();
    ctx.strokeStyle = isSelected ? 'rgba(78, 154, 245, 0.8)' : `rgba(${r}, ${g}, ${b}, 0.5)`;
    ctx.lineWidth = isSelected ? 2 : 0.8;
    ctx.stroke();
  }

  if (isSelected) {
    // Draw wireframe overlay with glow
    const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
    ctx.shadowColor = 'rgba(78, 154, 245, 0.6)';
    ctx.shadowBlur = 10;
    ctx.setLineDash([3, 3]);
    ctx.strokeStyle = 'rgba(78, 154, 245, 0.6)';
    ctx.lineWidth = 1.5;
    for (const [a, b] of edges) {
      if (corners[a] && corners[b]) {
        ctx.beginPath();
        ctx.moveTo(corners[a].x, corners[a].y);
        ctx.lineTo(corners[b].x, corners[b].y);
        ctx.stroke();
      }
    }
    ctx.setLineDash([]);
    ctx.shadowBlur = 0;
  }
}

function drawAxesIndicator(ctx) {
  const size = 40;
  const ox = 50, oy = previewCanvas.height - 50;

  const camPos = getCameraPos();
  const forward = vnorm(vsub(camera.target, camPos));
  const right = vnorm(vcross(forward, [0, 1, 0]));
  const up = vcross(right, forward);

  function projectAxis(dir) {
    const x = vdot(dir, right);
    const y = vdot(dir, up);
    return { x: ox + x * size, y: oy - y * size };
  }

  const axes = [
    { dir: [1, 0, 0], color: '#e06060', label: 'X' },
    { dir: [0, 1, 0], color: '#60c060', label: 'Y' },
    { dir: [0, 0, 1], color: '#6080e0', label: 'Z' },
  ];

  for (const axis of axes) {
    const p = projectAxis(axis.dir);
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(p.x, p.y);
    ctx.strokeStyle = axis.color;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = axis.color;
    ctx.font = 'bold 10px sans-serif';
    const dx = p.x - ox, dy = p.y - oy;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len > 5) {
      ctx.fillText(axis.label, p.x + dx/len * 8 - 3, p.y + dy/len * 8 + 3);
    }
  }
}

// ============================================================
// Vector Math
// ============================================================
function v3(x,y,z) { return [x,y,z]; }
function vadd(a,b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
function vsub(a,b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function vmul(a,s) { return [a[0]*s, a[1]*s, a[2]*s]; }
function vmulv(a,b) { return [a[0]*b[0], a[1]*b[1], a[2]*b[2]]; }
function vdot(a,b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function vlen(a) { return Math.sqrt(vdot(a,a)); }
function vnorm(a) { const l=vlen(a); return l>0?vmul(a,1/l):[0,0,0]; }
function vcross(a,b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function vreflect(v,n) { return vsub(v, vmul(n, 2*vdot(v,n))); }
function vlerp(a,b,t) { return vadd(vmul(a,1-t), vmul(b,t)); }

// ============================================================
// Random
// ============================================================
function rand() { return Math.random(); }

function randomInUnitSphere() {
  while (true) {
    const p = [rand()*2-1, rand()*2-1, rand()*2-1];
    if (vdot(p,p) < 1) return p;
  }
}

function randomInUnitDisk() {
  while (true) {
    const p = [rand()*2-1, rand()*2-1, 0];
    if (p[0]*p[0] + p[1]*p[1] < 1) return p;
  }
}

function randomCosineDirection(n) {
  const r1 = rand(), r2 = rand();
  const phi = 2 * Math.PI * r1;
  const sqrtR2 = Math.sqrt(r2);
  const x = Math.cos(phi) * sqrtR2;
  const y = Math.sin(phi) * sqrtR2;
  const z = Math.sqrt(1 - r2);
  const w = n;
  const a = Math.abs(w[0]) > 0.9 ? v3(0,1,0) : v3(1,0,0);
  const u = vnorm(vcross(a, w));
  const v = vcross(w, u);
  return vnorm(vadd(vadd(vmul(u, x), vmul(v, y)), vmul(w, z)));
}

// ============================================================
// Ray-Object Intersection
// ============================================================
function intersectSphere(ro, rd, center, radius) {
  const oc = vsub(ro, center);
  const a = vdot(rd, rd);
  const b = vdot(oc, rd);
  const c = vdot(oc, oc) - radius * radius;
  const disc = b*b - a*c;
  if (disc < 0) return null;
  const sqrtDisc = Math.sqrt(disc);
  let t = (-b - sqrtDisc) / a;
  if (t < 0.001) {
    t = (-b + sqrtDisc) / a;
    if (t < 0.001) return null;
  }
  const p = vadd(ro, vmul(rd, t));
  const n = vnorm(vsub(p, center));
  return { t, p, n };
}

function intersectBox(ro, rd, center, halfSize) {
  const mn = vsub(center, [halfSize, halfSize, halfSize]);
  const mx = vadd(center, [halfSize, halfSize, halfSize]);
  let tmin = -Infinity, tmax = Infinity;
  let nmin = [0,0,0];

  for (let i = 0; i < 3; i++) {
    if (Math.abs(rd[i]) < 1e-8) {
      if (ro[i] < mn[i] || ro[i] > mx[i]) return null;
      continue;
    }
    const invD = 1 / rd[i];
    let t1 = (mn[i] - ro[i]) * invD;
    let t2 = (mx[i] - ro[i]) * invD;
    let n1 = [0,0,0]; n1[i] = -1;
    let n2 = [0,0,0]; n2[i] = 1;
    if (invD < 0) { [t1,t2] = [t2,t1]; [n1,n2] = [n2,n1]; }
    if (t1 > tmin) { tmin = t1; nmin = n1; }
    if (t2 < tmax) { tmax = t2; }
    if (tmin > tmax) return null;
  }

  let t = tmin;
  let n = nmin;
  if (t < 0.001) {
    t = tmax;
    let exitN = [0,0,0];
    for (let i = 0; i < 3; i++) {
      if (Math.abs(rd[i]) < 1e-8) continue;
      const invD = 1 / rd[i];
      let t2 = ((invD > 0 ? center[i]+halfSize : center[i]-halfSize) - ro[i]) * invD;
      if (Math.abs(t2 - tmax) < 0.0001) {
        exitN[i] = invD > 0 ? 1 : -1;
      }
    }
    n = exitN;
    if (t < 0.001) return null;
  }

  const p = vadd(ro, vmul(rd, t));
  return { t, p, n: vnorm(n) };
}

function intersectPlane(ro, rd, y) {
  if (Math.abs(rd[1]) < 1e-8) return null;
  const t = (y - ro[1]) / rd[1];
  if (t < 0.001) return null;
  const p = vadd(ro, vmul(rd, t));
  return { t, p, n: [0, 1, 0] };
}

function intersectWallPlane(ro, rd, wall) {
  let idx, val, dir;
  if (wall.plane === 'x') { idx = 0; }
  else if (wall.plane === 'y') { idx = 1; }
  else { idx = 2; }
  val = wall.val;
  dir = wall.dir;

  if (Math.abs(rd[idx]) < 1e-8) return null;
  const t = (val - ro[idx]) / rd[idx];
  if (t < 0.001) return null;
  const p = vadd(ro, vmul(rd, t));

  // Check bounds
  for (let i = 0; i < 3; i++) {
    if (i === idx) continue;
    if (p[i] < wall.min[i] || p[i] > wall.max[i]) return null;
  }

  const n = [0, 0, 0];
  n[idx] = dir;
  return { t, p, n };
}

// ============================================================
// Scene Intersection (with room support)
// ============================================================
function intersectScene(ro, rd) {
  let closest = null;
  let closestT = Infinity;
  const room = roomPresets[currentRoom];

  const gnd = intersectPlane(ro, rd, 0);
  if (gnd && gnd.t < closestT) {
    closestT = gnd.t;
    closest = { ...gnd, material: 'ground' };
  }

  // Room walls
  if (room.walls) {
    for (const wall of room.walls) {
      const hit = intersectWallPlane(ro, rd, wall);
      if (hit && hit.t < closestT) {
        closestT = hit.t;
        closest = { ...hit, material: 'wall', color: wall.color };
      }
    }
  }

  // Ceiling light (for cornell box)
  if (room.ceilingLight) {
    const light = room.ceilingLight;
    const lHit = intersectPlane(ro, rd, light.center[1]);
    if (lHit && lHit.t < closestT) {
      const dx = Math.abs(lHit.p[0] - light.center[0]);
      const dz = Math.abs(lHit.p[2] - light.center[2]);
      if (dx < light.size && dz < light.size) {
        closestT = lHit.t;
        closest = { ...lHit, material: 'emissive', emission: light.emission };
      }
    }
  }

  for (const obj of sceneObjects) {
    let hit;
    if (obj.type === 'sphere') {
      hit = intersectSphere(ro, rd, obj.pos, obj.size);
    } else {
      hit = intersectBox(ro, rd, obj.pos, obj.size);
    }
    if (hit && hit.t < closestT) {
      closestT = hit.t;
      closest = { ...hit, material: 'glass', color: obj.color, ior: obj.ior };
    }
  }

  return closest;
}

// ============================================================
// Environment / Sky (uses current room)
// ============================================================
function skyColor(rd) {
  return roomPresets[currentRoom].sky(rd);
}

// ============================================================
// Fresnel (Schlick)
// ============================================================
function schlick(cosTheta, ior) {
  let r0 = (1 - ior) / (1 + ior);
  r0 = r0 * r0;
  return r0 + (1 - r0) * Math.pow(1 - cosTheta, 5);
}

// ============================================================
// Path Tracing
// ============================================================
function tracePath(ro, rd, maxBounces) {
  let throughput = [1, 1, 1];
  let color = [0, 0, 0];
  let curRo = ro, curRd = rd;
  const room = roomPresets[currentRoom];

  for (let bounce = 0; bounce < maxBounces; bounce++) {
    const hit = intersectScene(curRo, curRd);

    if (!hit) {
      color = vadd(color, vmulv(throughput, skyColor(curRd)));
      break;
    }

    if (hit.material === 'emissive') {
      color = vadd(color, vmulv(throughput, hit.emission));
      break;
    }

    if (hit.material === 'ground') {
      const albedo = room.ground(hit.p);
      throughput = vmulv(throughput, albedo);
      curRo = vadd(hit.p, vmul(hit.n, 0.001));
      curRd = randomCosineDirection(hit.n);
      continue;
    }

    if (hit.material === 'wall') {
      throughput = vmulv(throughput, hit.color);
      curRo = vadd(hit.p, vmul(hit.n, 0.001));
      curRd = randomCosineDirection(hit.n);
      continue;
    }

    if (hit.material === 'glass') {
      let n = hit.n;
      let eta;
      let frontFace = vdot(curRd, n) < 0;

      if (frontFace) {
        eta = 1.0 / hit.ior;
      } else {
        n = vmul(n, -1);
        eta = hit.ior;
      }

      const cosI = Math.min(-vdot(curRd, n), 1.0);
      const sin2T = eta * eta * (1 - cosI * cosI);

      if (!frontFace) {
        const dist = hit.t;
        const absorbColor = hit.color;
        const absorption = [
          Math.exp(-(1 - absorbColor[0]) * 2 * dist),
          Math.exp(-(1 - absorbColor[1]) * 2 * dist),
          Math.exp(-(1 - absorbColor[2]) * 2 * dist)
        ];
        throughput = vmulv(throughput, absorption);
      }

      const reflectance = schlick(cosI, eta);

      if (sin2T > 1.0 || rand() < reflectance) {
        curRd = vreflect(curRd, n);
        curRo = vadd(hit.p, vmul(n, 0.001));
      } else {
        const perpendicular = vmul(vadd(curRd, vmul(n, cosI)), eta);
        const parallel = vmul(n, -Math.sqrt(Math.abs(1 - vdot(perpendicular, perpendicular))));
        curRd = vnorm(vadd(perpendicular, parallel));
        curRo = vsub(hit.p, vmul(n, 0.001));
      }
      continue;
    }
  }

  return color;
}

// ============================================================
// Rendering (with Depth of Field)
// ============================================================
const renderCanvas = document.getElementById('render-canvas');
const renderCtx = renderCanvas.getContext('2d');
let imgData;
let W, H;

function setupRenderCanvas() {
  const vp = document.getElementById('viewport');
  const scale = parseFloat(document.getElementById('res-scale').value);
  W = Math.floor(vp.clientWidth * scale);
  H = Math.floor(vp.clientHeight * scale);
  renderCanvas.width = W;
  renderCanvas.height = H;
  renderCanvas.style.width = vp.clientWidth + 'px';
  renderCanvas.style.height = vp.clientHeight + 'px';
  imgData = renderCtx.createImageData(W, H);
  accumBuffer = new Float64Array(W * H * 3);
  sampleCount = 0;
  document.getElementById('status-resolution').textContent = `${W}√ó${H}`;
}

function renderSample() {
  const fovRad = camera.fov * Math.PI / 180;
  const aspect = W / H;
  const camPos = getCameraPos();
  const camDir = vnorm(vsub(camera.target, camPos));
  const camRight = vnorm(vcross(camDir, [0, 1, 0]));
  const camUp = vcross(camRight, camDir);
  const halfH = Math.tan(fovRad / 2);
  const halfW = halfH * aspect;
  const maxBounces = parseInt(document.getElementById('max-bounces').value) || 8;
  const focusDist = camera.focusDist;
  const aperture = camera.aperture;

  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      const u = (2 * (x + rand()) / W - 1) * halfW;
      const v = (1 - 2 * (y + rand()) / H) * halfH;
      const rd = vnorm(vadd(vadd(vmul(camRight, u), vmul(camUp, v)), camDir));

      // Depth of field: thin lens model
      let finalRo = camPos;
      let finalRd = rd;

      if (aperture > 0.001) {
        // Focus point along the primary ray at focusDist
        const focusPoint = vadd(camPos, vmul(rd, focusDist / vdot(rd, camDir)));
        // Random point on lens disk
        const disk = randomInUnitDisk();
        const lensOffset = vadd(vmul(camRight, disk[0] * aperture), vmul(camUp, disk[1] * aperture));
        finalRo = vadd(camPos, lensOffset);
        finalRd = vnorm(vsub(focusPoint, finalRo));
      }

      const color = tracePath(finalRo, finalRd, maxBounces);
      const idx = (y * W + x) * 3;
      accumBuffer[idx] += color[0];
      accumBuffer[idx + 1] += color[1];
      accumBuffer[idx + 2] += color[2];
    }
  }

  sampleCount++;

  const invS = 1 / sampleCount;
  for (let i = 0; i < W * H; i++) {
    const r = accumBuffer[i * 3] * invS;
    const g = accumBuffer[i * 3 + 1] * invS;
    const b = accumBuffer[i * 3 + 2] * invS;
    imgData.data[i * 4] = Math.min(255, Math.pow(r / (r + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 1] = Math.min(255, Math.pow(g / (g + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 2] = Math.min(255, Math.pow(b / (b + 1), 1/2.2) * 255) | 0;
    imgData.data[i * 4 + 3] = 255;
  }

  renderCtx.putImageData(imgData, 0, 0);

  const targetSpp = parseInt(document.getElementById('target-spp').value) || 100;
  const pct = Math.min(100, Math.round(sampleCount / targetSpp * 100));
  document.getElementById('progress-fill').style.width = pct + '%';
  document.getElementById('render-status-text').textContent = `${sampleCount} / ${targetSpp} spp (${pct}%)`;
  document.getElementById('status-text').textContent = `Rendering: ${sampleCount} spp`;

  if (sampleCount >= targetSpp) {
    finishRender();
  }
}

function renderLoop() {
  if (!rendering) return;
  const start = performance.now();
  renderSample();
  const elapsed = performance.now() - start;
  animFrameId = setTimeout(() => {
    if (rendering) renderLoop();
  }, Math.max(1, 16 - elapsed));
}

function switchToRenderMode() {
  appMode = 'render';
  previewCanvas.classList.add('hidden');
  renderCanvas.classList.remove('hidden');
  document.getElementById('render-overlay').classList.add('active');
  document.getElementById('btn-render').classList.add('hidden');
  document.getElementById('btn-stop').classList.remove('hidden');
  document.getElementById('btn-back').classList.remove('hidden');
  document.getElementById('mode-badge').textContent = 'RENDER';
  document.getElementById('mode-badge').classList.add('rendering');
  document.getElementById('status-dot').classList.remove('idle');
  document.getElementById('status-dot').classList.add('rendering');
}

function switchToEditMode() {
  appMode = 'edit';
  previewCanvas.classList.remove('hidden');
  renderCanvas.classList.add('hidden');
  document.getElementById('render-overlay').classList.remove('active');
  document.getElementById('btn-render').classList.remove('hidden');
  document.getElementById('btn-stop').classList.add('hidden');
  document.getElementById('btn-back').classList.add('hidden');
  document.getElementById('mode-badge').textContent = 'EDIT';
  document.getElementById('mode-badge').classList.remove('rendering');
  document.getElementById('status-dot').classList.add('idle');
  document.getElementById('status-dot').classList.remove('rendering');
  document.getElementById('status-text').textContent = 'Ready';
  drawPreview();
}

function startRender() {
  stopRender();
  switchToRenderMode();
  setupRenderCanvas();
  rendering = true;
  document.getElementById('status-text').textContent = 'Rendering...';
  renderLoop();
}

function stopRender() {
  rendering = false;
  if (animFrameId) {
    clearTimeout(animFrameId);
    animFrameId = null;
  }
  if (sampleCount > 0) {
    document.getElementById('status-text').textContent = `Stopped at ${sampleCount} spp`;
    document.getElementById('status-dot').classList.remove('rendering');
    document.getElementById('status-dot').classList.add('idle');
  }
}

function finishRender() {
  rendering = false;
  if (animFrameId) {
    clearTimeout(animFrameId);
    animFrameId = null;
  }
  document.getElementById('status-text').textContent = `Complete: ${sampleCount} spp`;
  document.getElementById('status-dot').classList.remove('rendering');
  document.getElementById('status-dot').classList.add('idle');
  document.getElementById('btn-stop').classList.add('hidden');
}

function backToEdit() {
  stopRender();
  switchToEditMode();
}

// ============================================================
// Default Scene
// ============================================================
function addDefaultScene() {
  sceneObjects.push(
    { type: 'sphere', pos: [0, 1, -4], size: 1, color: [0.9, 0.95, 1.0], colorHex: '#e6f0ff', ior: 1.5 },
    { type: 'sphere', pos: [-2.2, 0.7, -3.5], size: 0.7, color: [0.5, 0.8, 1.0], colorHex: '#80ccff', ior: 1.45 },
    { type: 'cube', pos: [2, 0.8, -3.5], size: 0.8, color: [1.0, 0.6, 0.6], colorHex: '#ff9999', ior: 1.7 },
    { type: 'sphere', pos: [0.8, 0.5, -2], size: 0.5, color: [0.6, 1.0, 0.6], colorHex: '#99ff99', ior: 1.3 }
  );
  selectedIndex = 0;
  updateObjectList();
  loadProperties();
}

// ============================================================
// Init
// ============================================================
addDefaultScene();
initCameraControls();
updateCamInfo();

window.addEventListener('resize', () => {
  if (appMode === 'edit') drawPreview();
  else if (rendering) startRender();
});

// Initial draw
requestAnimationFrame(() => drawPreview());
</script>
</body>
</html>
